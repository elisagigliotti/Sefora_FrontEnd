/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport",
)

package it.unical.informatica.ea.sefora_frontend.apis

import it.unical.informatica.ea.sefora_frontend.BuildConfig
import it.unical.informatica.ea.sefora_frontend.auth.TokenManager
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.runBlocking
import kotlinx.coroutines.withContext
import okhttp3.HttpUrl
import okhttp3.OkHttpClient
import it.unical.informatica.ea.sefora_frontend.infrastructure.ApiClient
import it.unical.informatica.ea.sefora_frontend.infrastructure.ApiResponse
import it.unical.informatica.ea.sefora_frontend.infrastructure.ClientError
import it.unical.informatica.ea.sefora_frontend.infrastructure.ClientException
import it.unical.informatica.ea.sefora_frontend.infrastructure.MultiValueMap
import it.unical.informatica.ea.sefora_frontend.infrastructure.RequestConfig
import it.unical.informatica.ea.sefora_frontend.infrastructure.RequestMethod
import it.unical.informatica.ea.sefora_frontend.infrastructure.ResponseType
import it.unical.informatica.ea.sefora_frontend.infrastructure.ServerError
import it.unical.informatica.ea.sefora_frontend.infrastructure.ServerException
import it.unical.informatica.ea.sefora_frontend.infrastructure.Success
import it.unical.informatica.ea.sefora_frontend.models.AccountDto
import it.unical.informatica.ea.sefora_frontend.models.AccountShortDto
import it.unical.informatica.ea.sefora_frontend.models.AuthenticationRequest
import it.unical.informatica.ea.sefora_frontend.models.AuthenticationResponse
import it.unical.informatica.ea.sefora_frontend.models.ChangePasswordRequest
import it.unical.informatica.ea.sefora_frontend.models.RegisterRequest
import java.io.IOException
import javax.inject.Inject

class AccountControllerApi (
    basePath: kotlin.String = defaultBasePath,
    client: OkHttpClient = ApiClient.defaultClient,
) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, BuildConfig.SERVER_ADDRESS)
        }
    }



    /**
     *
     *
     * @param authenticationRequest
     * @return AuthenticationResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(
        IllegalStateException::class,
        IOException::class,
        UnsupportedOperationException::class,
        ClientException::class,
        ServerException::class,
    )
    suspend fun authenticate(authenticationRequest: AuthenticationRequest): AuthenticationResponse = withContext(Dispatchers.IO) {
        val localVarResponse = authenticateWithHttpInfo(authenticationRequest = authenticationRequest)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AuthenticationResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException(
                    "Client error : ${localVarError.statusCode} ${localVarError.message}",
                    localVarError.statusCode,
                    localVarResponse,
                )
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException(
                    "Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}",
                    localVarError.statusCode,
                    localVarResponse,
                )
            }
        }
    }

    /**
     *
     *
     * @param authenticationRequest
     * @return ApiResponse<AuthenticationResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun authenticateWithHttpInfo(authenticationRequest: AuthenticationRequest): ApiResponse<AuthenticationResponse?> {
        val localVariableConfig = authenticateRequestConfig(authenticationRequest = authenticationRequest)

        return request<AuthenticationRequest, AuthenticationResponse>(
            localVariableConfig,
        )
    }

    /**
     * To obtain the request config of the operation authenticate
     *
     * @param authenticationRequest
     * @return RequestConfig
     */
    fun authenticateRequestConfig(authenticationRequest: AuthenticationRequest): RequestConfig<AuthenticationRequest> {
        val localVariableBody = authenticationRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/account/authenticate",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody,
        )
    }

    /**
     *
     *
     * @param accountId
     * @return kotlin.Any
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(
        IllegalStateException::class,
        IOException::class,
        UnsupportedOperationException::class,
        ClientException::class,
        ServerException::class,
    )
    fun banAccount(accountId: kotlin.Long, token: String) = runBlocking(Dispatchers.IO) {
        val localVarResponse = banAccountWithHttpInfo(accountId = accountId, token = token)

        return@runBlocking when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>)
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException(
                    "Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}",
                    localVarError.statusCode,
                    localVarResponse,
                )
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException(
                    "Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}",
                    localVarError.statusCode,
                    localVarResponse,
                )
            }
        }
    }

    /**
     *
     *
     * @param accountId
     * @return ApiResponse<kotlin.Any?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun banAccountWithHttpInfo(accountId: kotlin.Long, token: String): ApiResponse<kotlin.Any?> {
        val localVariableConfig = banAccountRequestConfig(accountId = accountId, token = token)

        return request<Unit, kotlin.Any>(
            localVariableConfig,
        )
    }

    /**
     * To obtain the request config of the operation banAccount
     *
     * @param accountId
     * @return RequestConfig
     */
    fun banAccountRequestConfig(accountId: kotlin.Long, token: String): RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        localVariableHeaders["Authorization"] = "Bearer $token"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/api/account/ban/{accountId}".replace("{" + "accountId" + "}", encodeURIComponent(accountId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody,
        )
    }

    /**
     *
     *
     * @param changePasswordRequest
     * @return kotlin.Any
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(
        IllegalStateException::class,
        IOException::class,
        UnsupportedOperationException::class,
        ClientException::class,
        ServerException::class,
    )
    fun changePassword(changePasswordRequest: ChangePasswordRequest, token: String): kotlin.Any = runBlocking(Dispatchers.IO) {
        val localVarResponse = changePasswordWithHttpInfo(changePasswordRequest = changePasswordRequest, token = token)

        return@runBlocking when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>)
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException(
                    "Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}",
                    localVarError.statusCode,
                    localVarResponse,
                )
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException(
                    "Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}",
                    localVarError.statusCode,
                    localVarResponse,
                )
            }
        }
    }

    /**
     *
     *
     * @param changePasswordRequest
     * @return ApiResponse<kotlin.Any?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun changePasswordWithHttpInfo(changePasswordRequest: ChangePasswordRequest, token: String): ApiResponse<kotlin.Any?> {
        val localVariableConfig = changePasswordRequestConfig(changePasswordRequest = changePasswordRequest, token = token)

        return request<ChangePasswordRequest, kotlin.Any>(
            localVariableConfig,
        )
    }

    /**
     * To obtain the request config of the operation changePassword
     *
     * @param changePasswordRequest
     * @return RequestConfig
     */
    fun changePasswordRequestConfig(changePasswordRequest: ChangePasswordRequest, token: String): RequestConfig<ChangePasswordRequest> {
        val localVariableBody = changePasswordRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"

        localVariableHeaders["Authorization"] = "Bearer $token"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/api/account",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody,
        )
    }

    /**
     *
     *
     * @param accountId
     * @return kotlin.Any
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(
        IllegalStateException::class,
        IOException::class,
        UnsupportedOperationException::class,
        ClientException::class,
        ServerException::class,
    )
    fun deleteAccount(accountId: kotlin.Long, token: String) = runBlocking(Dispatchers.IO) {
        val localVarResponse = deleteAccountWithHttpInfo(accountId = accountId, token = token)

        return@runBlocking when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>)
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException(
                    "Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}",
                    localVarError.statusCode,
                    localVarResponse,
                )
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException(
                    "Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}",
                    localVarError.statusCode,
                    localVarResponse,
                )
            }
        }
    }

    /**
     *
     *
     * @param accountId
     * @return ApiResponse<kotlin.Any?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteAccountWithHttpInfo(accountId: kotlin.Long, token: String): ApiResponse<kotlin.Any?> {
        val localVariableConfig = deleteAccountRequestConfig(accountId = accountId, token = token)

        return request<Unit, kotlin.Any>(
            localVariableConfig,
        )
    }

    /**
     * To obtain the request config of the operation deleteAccount
     *
     * @param accountId
     * @return RequestConfig
     */
    fun deleteAccountRequestConfig(accountId: kotlin.Long, token: String): RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        localVariableHeaders["Authorization"] = "Bearer $token"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/account/delete/{accountId}".replace("{" + "accountId" + "}", encodeURIComponent(accountId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody,
        )
    }

    /**
     *
     *
     * @param accountId
     * @return AccountDto
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(
        IllegalStateException::class,
        IOException::class,
        UnsupportedOperationException::class,
        ClientException::class,
        ServerException::class,
    )
    fun getAccountById(accountId: kotlin.Long): AccountDto = runBlocking(Dispatchers.IO) {
        val localVarResponse = getAccountByIdWithHttpInfo(accountId = accountId)

        return@runBlocking when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AccountDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException(
                    "Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}",
                    localVarError.statusCode,
                    localVarResponse,
                )
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException(
                    "Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}",
                    localVarError.statusCode,
                    localVarResponse,
                )
            }
        }
    }

    /**
     *
     *
     * @param accountId
     * @return ApiResponse<AccountDto?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getAccountByIdWithHttpInfo(accountId: kotlin.Long): ApiResponse<AccountDto?> {
        val localVariableConfig = getAccountByIdRequestConfig(accountId = accountId)

        return request<Unit, AccountDto>(
            localVariableConfig,
        )
    }

    /**
     * To obtain the request config of the operation getAccountById
     *
     * @param accountId
     * @return RequestConfig
     */
    fun getAccountByIdRequestConfig(accountId: kotlin.Long): RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/account/{accountId}".replace("{" + "accountId" + "}", encodeURIComponent(accountId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody,
        )
    }

    /**
     *
     *
     * @return kotlin.collections.List<AccountShortDto>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getAllAccounts(token: String) : kotlin.collections.List<AccountShortDto> = withContext(Dispatchers.IO) {
        val localVarResponse = getAllAccountsWithHttpInfo(token = token)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<AccountShortDto>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     *
     *
     * @return ApiResponse<kotlin.collections.List<AccountShortDto>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getAllAccountsWithHttpInfo(token: String) : ApiResponse<kotlin.collections.List<AccountShortDto>?> {
        val localVariableConfig = getAllAccountsRequestConfig(token = token)

        return request<Unit, kotlin.collections.List<AccountShortDto>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getAllAccounts
     *
     * @return RequestConfig
     */
    fun getAllAccountsRequestConfig(token: String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        localVariableHeaders["Authorization"] = "Bearer $token"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/account/all",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     *
     *
     * @return AccountDto
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(
        IllegalStateException::class,
        IOException::class,
        UnsupportedOperationException::class,
        ClientException::class,
        ServerException::class,
    )
    fun getConnectedAccount(token: String): AccountDto = runBlocking(Dispatchers.IO) {
        val localVarResponse = getConnectedAccountWithHttpInfo(token)

        return@runBlocking when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AccountDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException(
                    "Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}",
                    localVarError.statusCode,
                    localVarResponse,
                )
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException(
                    "Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}",
                    localVarError.statusCode,
                    localVarResponse,
                )
            }
        }
    }

    /**
     *
     *
     * @return ApiResponse<AccountDto?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getConnectedAccountWithHttpInfo(token: String): ApiResponse<AccountDto?> {
        val localVariableConfig = getConnectedAccountRequestConfig(token)

        return request<Unit, AccountDto>(
            localVariableConfig,
        )
    }

    /**
     * To obtain the request config of the operation getConnectedAccount
     *
     * @return RequestConfig
     */
    fun getConnectedAccountRequestConfig(token: String): RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        localVariableHeaders["Authorization"] = "Bearer $token"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/account/current",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody,
        )
    }



    /**
     *
     *
     * @return kotlin.Any
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(
        IllegalStateException::class,
        IOException::class,
        UnsupportedOperationException::class,
        ClientException::class,
        ServerException::class,
    )
    fun logout(token: String) = runBlocking(Dispatchers.IO) {
        val localVarResponse = logoutWithHttpInfo(token)

        return@runBlocking when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>)
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException(
                    "Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}",
                    localVarError.statusCode,
                    localVarResponse,
                )
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException(
                    "Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}",
                    localVarError.statusCode,
                    localVarResponse,
                )
            }
        }
    }

    /**
     *
     *
     * @return ApiResponse<kotlin.Any?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun logoutWithHttpInfo(token: String): ApiResponse<kotlin.Any?> {
        val localVariableConfig = logoutRequestConfig(token)

        return request<Unit, kotlin.Any>(
            localVariableConfig,
        )
    }

    /**
     * To obtain the request config of the operation logout
     *
     * @return RequestConfig
     */
    fun logoutRequestConfig(token: String): RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        localVariableHeaders["Authorization"] = "Bearer $token"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/account/logout",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody,
        )
    }

    /**
     *
     *
     * @param accountId
     * @return kotlin.Any
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(
        IllegalStateException::class,
        IOException::class,
        UnsupportedOperationException::class,
        ClientException::class,
        ServerException::class,
    )
    fun makeAdmin(accountId: kotlin.Long, token: String) = runBlocking(Dispatchers.IO) {
        val localVarResponse = makeAdminWithHttpInfo(accountId = accountId, token = token)

        return@runBlocking when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>)
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException(
                    "Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}",
                    localVarError.statusCode,
                    localVarResponse,
                )
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException(
                    "Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}",
                    localVarError.statusCode,
                    localVarResponse,
                )
            }
        }
    }

    /**
     *
     *
     * @param accountId
     * @return ApiResponse<kotlin.Any?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun makeAdminWithHttpInfo(accountId: kotlin.Long, token: String): ApiResponse<kotlin.Any?> {
        val localVariableConfig = makeAdminRequestConfig(accountId = accountId, token = token)

        return request<Unit, kotlin.Any>(
            localVariableConfig,
        )
    }

    /**
     * To obtain the request config of the operation makeAdmin
     *
     * @param accountId
     * @return RequestConfig
     */
    fun makeAdminRequestConfig(accountId: kotlin.Long, token: String): RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        localVariableHeaders["Authorization"] = "Bearer $token"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/api/account/makeAdmin/{accountId}".replace("{" + "accountId" + "}", encodeURIComponent(accountId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody,
        )
    }

    /**
     *
     *
     * @return AuthenticationResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(
        IllegalStateException::class,
        IOException::class,
        UnsupportedOperationException::class,
        ClientException::class,
        ServerException::class,
    )
    fun refreshToken(): AuthenticationResponse = runBlocking(Dispatchers.IO) {
        val localVarResponse = refreshTokenWithHttpInfo()

        return@runBlocking when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AuthenticationResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException(
                    "Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}",
                    localVarError.statusCode,
                    localVarResponse,
                )
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException(
                    "Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}",
                    localVarError.statusCode,
                    localVarResponse,
                )
            }
        }
    }

    /**
     *
     *
     * @return ApiResponse<AuthenticationResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun refreshTokenWithHttpInfo(): ApiResponse<AuthenticationResponse?> {
        val localVariableConfig = refreshTokenRequestConfig()

        return request<Unit, AuthenticationResponse>(
            localVariableConfig,
        )
    }

    /**
     * To obtain the request config of the operation refreshToken
     *
     * @return RequestConfig
     */
    fun refreshTokenRequestConfig(): RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/account/refresh-token",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody,
        )
    }

    /**
     *
     *
     * @param registerRequest
     * @return AuthenticationResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(
        IllegalStateException::class,
        IOException::class,
        UnsupportedOperationException::class,
        ClientException::class,
        ServerException::class,
    )
    fun register(registerRequest: RegisterRequest): AuthenticationResponse = runBlocking(Dispatchers.IO) {
        val localVarResponse = registerWithHttpInfo(registerRequest = registerRequest)

        return@runBlocking when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AuthenticationResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException(
                    "Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}",
                    localVarError.statusCode,
                    localVarResponse,
                )
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException(
                    "Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}",
                    localVarError.statusCode,
                    localVarResponse,
                )
            }
        }
    }

    /**
     *
     *
     * @param registerRequest
     * @return ApiResponse<AuthenticationResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun registerWithHttpInfo(registerRequest: RegisterRequest): ApiResponse<AuthenticationResponse?> {
        val localVariableConfig = registerRequestConfig(registerRequest = registerRequest)

        return request<RegisterRequest, AuthenticationResponse>(
            localVariableConfig,
        )
    }

    /**
     * To obtain the request config of the operation register
     *
     * @param registerRequest
     * @return RequestConfig
     */
    fun registerRequestConfig(registerRequest: RegisterRequest): RequestConfig<RegisterRequest> {
        val localVariableBody = registerRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/account/register",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody,
        )
    }

    /**
     *
     *
     * @param accountId
     * @return kotlin.Any
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(
        IllegalStateException::class,
        IOException::class,
        UnsupportedOperationException::class,
        ClientException::class,
        ServerException::class,
    )
    fun removeAdmin(accountId: kotlin.Long, token: String) = runBlocking(Dispatchers.IO) {
        val localVarResponse = removeAdminWithHttpInfo(accountId = accountId, token = token)

        return@runBlocking when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>)
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException(
                    "Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}",
                    localVarError.statusCode,
                    localVarResponse,
                )
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException(
                    "Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}",
                    localVarError.statusCode,
                    localVarResponse,
                )
            }
        }
    }

    /**
     *
     *
     * @param accountId
     * @return ApiResponse<kotlin.Any?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun removeAdminWithHttpInfo(accountId: kotlin.Long, token: String): ApiResponse<kotlin.Any?> {
        val localVariableConfig = removeAdminRequestConfig(accountId = accountId, token = token)

        return request<Unit, kotlin.Any>(
            localVariableConfig,
        )
    }

    /**
     * To obtain the request config of the operation removeAdmin
     *
     * @param accountId
     * @return RequestConfig
     */
    fun removeAdminRequestConfig(accountId: kotlin.Long, token: String): RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        localVariableHeaders["Authorization"] = "Bearer $token"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/api/account/removeAdmin/{accountId}".replace("{" + "accountId" + "}", encodeURIComponent(accountId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody,
        )
    }

    /**
     *
     *
     * @param accountId
     * @return kotlin.Any
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(
        IllegalStateException::class,
        IOException::class,
        UnsupportedOperationException::class,
        ClientException::class,
        ServerException::class,
    )
    fun unbanAccount(accountId: kotlin.Long, token: String) = runBlocking(Dispatchers.IO) {
        val localVarResponse = unbanAccountWithHttpInfo(accountId = accountId, token = token)

        return@runBlocking when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>)
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException(
                    "Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}",
                    localVarError.statusCode,
                    localVarResponse,
                )
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException(
                    "Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}",
                    localVarError.statusCode,
                    localVarResponse,
                )
            }
        }
    }

    /**
     *
     *
     * @param accountId
     * @return ApiResponse<kotlin.Any?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun unbanAccountWithHttpInfo(accountId: kotlin.Long, token: String): ApiResponse<kotlin.Any?> {
        val localVariableConfig = unbanAccountRequestConfig(accountId = accountId, token = token)

        return request<Unit, kotlin.Any>(
            localVariableConfig,
        )
    }

    /**
     * To obtain the request config of the operation unbanAccount
     *
     * @param accountId
     * @return RequestConfig
     */
    fun unbanAccountRequestConfig(accountId: kotlin.Long, token: String): RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        localVariableHeaders["Authorization"] = "Bearer $token"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/api/account/unban/{accountId}".replace("{" + "accountId" + "}", encodeURIComponent(accountId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody,
        )
    }

    /**
     *
     *
     * @param accountDto
     * @return kotlin.Any
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(
        IllegalStateException::class,
        IOException::class,
        UnsupportedOperationException::class,
        ClientException::class,
        ServerException::class,
    )
    fun updateAccount(accountDto: AccountDto, token: String): kotlin.Any = runBlocking(Dispatchers.IO) {
        val localVarResponse = updateAccountWithHttpInfo(accountDto = accountDto, token = token)

        return@runBlocking when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException(
                    "Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}",
                    localVarError.statusCode,
                    localVarResponse,
                )
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException(
                    "Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}",
                    localVarError.statusCode,
                    localVarResponse,
                )
            }
        }
    }

    /**
     *
     *
     * @param accountDto
     * @return ApiResponse<kotlin.Any?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun updateAccountWithHttpInfo(accountDto: AccountDto, token: String): ApiResponse<kotlin.Any?> {
        val localVariableConfig = updateAccountRequestConfig(accountDto = accountDto, token = token)

        return request<AccountDto, kotlin.Any>(
            localVariableConfig,
        )
    }

    /**
     * To obtain the request config of the operation updateAccount
     *
     * @param accountDto
     * @return RequestConfig
     */
    fun updateAccountRequestConfig(accountDto: AccountDto, token: String): RequestConfig<AccountDto> {
        val localVariableBody = accountDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"

        localVariableHeaders["Authorization"] = "Bearer $token"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/account",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody,
        )
    }

    /**
     *
     *
     * @param accountShortDto
     * @return kotlin.String
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(
        IllegalStateException::class,
        IOException::class,
        UnsupportedOperationException::class,
        ClientException::class,
        ServerException::class,
    )
    fun updateImage(accountShortDto: AccountShortDto, token: String) = runBlocking(Dispatchers.IO) {
        val localVarResponse = updateImageWithHttpInfo(accountShortDto = accountShortDto, token = token)

        return@runBlocking when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>)
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException(
                    "Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}",
                    localVarError.statusCode,
                    localVarResponse,
                )
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException(
                    "Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}",
                    localVarError.statusCode,
                    localVarResponse,
                )
            }
        }
    }

    /**
     *
     *
     * @param accountShortDto
     * @return ApiResponse<kotlin.String?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun updateImageWithHttpInfo(accountShortDto: AccountShortDto, token: String): ApiResponse<kotlin.String?> {
        val localVariableConfig = updateImageRequestConfig(accountShortDto = accountShortDto, token = token)

        return request<AccountShortDto, kotlin.String>(
            localVariableConfig,
        )
    }

    /**
     * To obtain the request config of the operation updateImage
     *
     * @param accountShortDto
     * @return RequestConfig
     */
    fun updateImageRequestConfig(accountShortDto: AccountShortDto, token: String): RequestConfig<AccountShortDto> {
        val localVariableBody = accountShortDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"

        localVariableHeaders["Authorization"] = "Bearer $token"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/api/account/update-image",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody,
        )
    }

    /**
     *
     *
     * @return kotlin.String
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(
        IllegalStateException::class,
        IOException::class,
        UnsupportedOperationException::class,
        ClientException::class,
        ServerException::class,
    )

    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl
            .Builder()
            .scheme("http")
            .host("localhost")
            .addPathSegment(uriComponent)
            .build()
            .encodedPathSegments[0]
}
