diff --git a/.idea/deploymentTargetSelector.xml b/.idea/deploymentTargetSelector.xml
index 3ade700..13cd667 100644
--- a/.idea/deploymentTargetSelector.xml
+++ b/.idea/deploymentTargetSelector.xml
@@ -4,10 +4,10 @@
     <selectionStates>
       <SelectionState runConfigName="app">
         <option name="selectionMode" value="DROPDOWN" />
-        <DropdownSelection timestamp="2024-07-12T21:20:49.199463800Z">
+        <DropdownSelection timestamp="2024-09-01T02:30:14.286423168Z">
           <Target type="DEFAULT_BOOT">
             <handle>
-              <DeviceId pluginId="Default" identifier="serial=192.168.1.122:34165;connection=bfd9c73e" />
+              <DeviceId pluginId="LocalEmulator" identifier="path=/home/elisagigliotti/.var/app/com.google.AndroidStudio/config/.android/avd/Pixel_3a_XL_API_30.avd" />
             </handle>
           </Target>
         </DropdownSelection>
diff --git a/.idea/inspectionProfiles/Project_Default.xml b/.idea/inspectionProfiles/Project_Default.xml
index 103e00c..1f57b99 100644
--- a/.idea/inspectionProfiles/Project_Default.xml
+++ b/.idea/inspectionProfiles/Project_Default.xml
@@ -1,6 +1,30 @@
 <component name="InspectionProjectProfileManager">
   <profile version="1.0">
     <option name="myName" value="Project Default" />
+    <inspection_tool class="ComposePreviewDimensionRespectsLimit" enabled="true" level="WARNING" enabled_by_default="true">
+      <option name="composableFile" value="true" />
+    </inspection_tool>
+    <inspection_tool class="ComposePreviewMustBeTopLevelFunction" enabled="true" level="ERROR" enabled_by_default="true">
+      <option name="composableFile" value="true" />
+    </inspection_tool>
+    <inspection_tool class="ComposePreviewNeedsComposableAnnotation" enabled="true" level="ERROR" enabled_by_default="true">
+      <option name="composableFile" value="true" />
+    </inspection_tool>
+    <inspection_tool class="ComposePreviewNotSupportedInUnitTestFiles" enabled="true" level="ERROR" enabled_by_default="true">
+      <option name="composableFile" value="true" />
+    </inspection_tool>
+    <inspection_tool class="GlancePreviewDimensionRespectsLimit" enabled="true" level="WARNING" enabled_by_default="true">
+      <option name="composableFile" value="true" />
+    </inspection_tool>
+    <inspection_tool class="GlancePreviewMustBeTopLevelFunction" enabled="true" level="ERROR" enabled_by_default="true">
+      <option name="composableFile" value="true" />
+    </inspection_tool>
+    <inspection_tool class="GlancePreviewNeedsComposableAnnotation" enabled="true" level="ERROR" enabled_by_default="true">
+      <option name="composableFile" value="true" />
+    </inspection_tool>
+    <inspection_tool class="GlancePreviewNotSupportedInUnitTestFiles" enabled="true" level="ERROR" enabled_by_default="true">
+      <option name="composableFile" value="true" />
+    </inspection_tool>
     <inspection_tool class="PreviewAnnotationInFunctionWithParameters" enabled="true" level="ERROR" enabled_by_default="true">
       <option name="composableFile" value="true" />
     </inspection_tool>
diff --git a/.idea/misc.xml b/.idea/misc.xml
index 5f2840b..8978d23 100644
--- a/.idea/misc.xml
+++ b/.idea/misc.xml
@@ -1,10 +1,9 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project version="4">
-  <component name="ExternalStorageConfigurationManager" enabled="true" />
-  <component name="ProjectRootManager" version="2" languageLevel="JDK_17" default="true" project-jdk-name="jbr-17" project-jdk-type="JavaSDK">
-    <output url="file://$PROJECT_DIR$/build/classes" />
-  </component>
-  <component name="ProjectType">
-    <option name="id" value="Android" />
-  </component>
+<project version="4">
+  <component name="ExternalStorageConfigurationManager" enabled="true" />
+  <component name="ProjectRootManager" version="2" languageLevel="JDK_17" default="true" project-jdk-name="jbr-17" project-jdk-type="JavaSDK">
+    <output url="file://$PROJECT_DIR$/build/classes" />
+  </component>
+  <component name="ProjectType">
+    <option name="id" value="Android" />
+  </component>
 </project>
\ No newline at end of file
diff --git a/app/build.gradle.kts b/app/build.gradle.kts
index acfdea7..d0fcfeb 100644
--- a/app/build.gradle.kts
+++ b/app/build.gradle.kts
@@ -1,6 +1,8 @@
 plugins {
     alias(libs.plugins.android.application)
     alias(libs.plugins.jetbrains.kotlin.android)
+    id("kotlin-kapt")
+    id("dagger.hilt.android.plugin")
 }
 
 android {
@@ -18,6 +20,7 @@ android {
         vectorDrawables {
             useSupportLibrary = true
         }
+        manifestPlaceholders["appAuthRedirectScheme"] = "yourSchemeName"
     }
 
     buildTypes {
@@ -63,7 +66,7 @@ android {
             dimension = "environment"
             applicationIdSuffix = ".wifi"
             versionNameSuffix = "-wifi"
-            buildConfigField("String", "SERVER_ADDRESS", "\"http://192.168.1.251:8080\"")
+            buildConfigField("String", "SERVER_ADDRESS", "\"http://192.168.0.251:8080\"")
         }
     }
 }
@@ -77,6 +80,7 @@ dependencies {
     implementation(libs.androidx.ui.graphics)
     implementation(libs.androidx.ui.tooling.preview)
     implementation(libs.androidx.material3)
+    implementation(libs.androidx.datastore.preferences.core.jvm)
     testImplementation(libs.junit)
     androidTestImplementation(libs.androidx.junit)
     androidTestImplementation(libs.androidx.espresso.core)
@@ -91,4 +95,19 @@ dependencies {
     implementation(libs.json)
     implementation(libs.moshi)
     implementation(libs.moshi.kotlin)
+    implementation(libs.datastore)
+    implementation(libs.security.crypto)
+    implementation(libs.androidx.datastore.preferences)
+    implementation(libs.jwtdecode)
+    implementation(libs.appauth)
+    implementation(libs.kotlinx.serialization.json)
+    implementation (libs.hilt.android)
+    kapt (libs.hilt.android.compiler)
+    kapt (libs.androidx.hilt.compiler)
+    implementation (libs.androidx.hilt.navigation.compose)
+    // Google Sign-In
+    implementation("com.google.android.gms:play-services-auth:20.2.0")
+    implementation("androidx.compose.material3:material3:1.0.0-beta03")
+    implementation("androidx.compose.ui:ui:1.3.2")
+    implementation("androidx.compose.ui:ui-tooling-preview:1.3.2")
 }
\ No newline at end of file
diff --git a/app/src/main/AndroidManifest.xml b/app/src/main/AndroidManifest.xml
index 10f754f..915857d 100644
--- a/app/src/main/AndroidManifest.xml
+++ b/app/src/main/AndroidManifest.xml
@@ -4,6 +4,7 @@
     <uses-permission android:name="android.permission.INTERNET" />
 
     <application
+        android:name=".SeforaApplication"
         android:allowBackup="true"
         android:usesCleartextTraffic="true"
         android:dataExtractionRules="@xml/data_extraction_rules"
@@ -15,13 +16,11 @@
         android:theme="@style/Theme.Sefora_FrontEnd"
         tools:targetApi="31">
         <activity
-            android:name=".MainActivity"
+            android:name=".activity.MainActivity"
             android:exported="true"
-            android:label="@string/app_name"
             android:theme="@style/Theme.Sefora_FrontEnd">
             <intent-filter>
                 <action android:name="android.intent.action.MAIN" />
-
                 <category android:name="android.intent.category.LAUNCHER" />
             </intent-filter>
         </activity>
diff --git a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/MainActivity.kt b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/MainActivity.kt
deleted file mode 100644
index 7971222..0000000
--- a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/MainActivity.kt
+++ /dev/null
@@ -1,206 +0,0 @@
-package it.unical.informatica.ea.sefora_frontend
-
-import android.content.Context
-import android.graphics.Bitmap
-import android.graphics.BitmapFactory
-import android.net.Uri
-import android.os.Bundle
-import androidx.activity.ComponentActivity
-import androidx.activity.compose.setContent
-import androidx.activity.enableEdgeToEdge
-import androidx.compose.foundation.layout.Arrangement
-import androidx.compose.foundation.layout.Column
-import androidx.compose.foundation.layout.padding
-import androidx.compose.material.icons.Icons
-import androidx.compose.material.icons.filled.FavoriteBorder
-import androidx.compose.material.icons.filled.Home
-import androidx.compose.material.icons.filled.Person
-import androidx.compose.material.icons.filled.Search
-import androidx.compose.material3.AlertDialog
-import androidx.compose.material3.BottomAppBar
-import androidx.compose.material3.Button
-import androidx.compose.material3.CenterAlignedTopAppBar
-import androidx.compose.material3.ExperimentalMaterial3Api
-import androidx.compose.material3.Icon
-import androidx.compose.material3.MaterialTheme
-import androidx.compose.material3.NavigationBar
-import androidx.compose.material3.NavigationBarItem
-import androidx.compose.material3.Scaffold
-import androidx.compose.material3.Text
-import androidx.compose.material3.TopAppBarDefaults.topAppBarColors
-import androidx.compose.runtime.Composable
-import androidx.compose.runtime.mutableIntStateOf
-import androidx.compose.runtime.mutableStateOf
-import androidx.compose.runtime.remember
-import androidx.compose.ui.Alignment
-import androidx.compose.ui.Modifier
-import androidx.compose.ui.platform.LocalContext
-import androidx.compose.ui.text.style.TextOverflow
-import androidx.compose.ui.unit.dp
-import it.unical.informatica.ea.sefora_frontend.activity.LoginActivity
-import it.unical.informatica.ea.sefora_frontend.ui.theme.Sefora_FrontEndTheme
-import it.unical.informatica.ea.sefora_frontend.viewmodel.LoginViewModel
-import java.io.FileNotFoundException
-
-class MainActivity : ComponentActivity() {
-    override fun onCreate(savedInstanceState: Bundle?) {
-        super.onCreate(savedInstanceState)
-        enableEdgeToEdge()
-        setContent {
-            Sefora_FrontEndTheme {
-                SeforaApp()
-            }
-        }
-    }
-}
-
-@OptIn(ExperimentalMaterial3Api::class)
-@Composable
-fun SeforaApp(
-    loginViewModel: LoginViewModel = LoginViewModel()
-) {
-    // index delle pagine
-    val selectedIndex = remember { mutableIntStateOf(0) }
-    // variabile che controlla l'apertura e chiusura della login bottomsheet
-    val showLogin = remember { mutableStateOf(false) }
-    Scaffold(
-        topBar = {
-            CenterAlignedTopAppBar(
-                colors = topAppBarColors(
-                    containerColor = MaterialTheme.colorScheme.primaryContainer,
-                    titleContentColor = MaterialTheme.colorScheme.primary,
-                ),
-                title = {
-                    Text(
-                        "S  E  F  O  R  A",
-                        maxLines = 1,
-                        overflow = TextOverflow.Ellipsis
-                    )
-                },
-            )
-        },
-        bottomBar = {
-            BottomAppBar{
-                NavigationBar{
-                    //Home
-                    NavigationBarItem(
-                        selected = selectedIndex.value == 0,
-                        onClick = { selectedIndex.value = 0 },
-                        icon = {
-                            Column(horizontalAlignment = Alignment.CenterHorizontally) {
-                                Icon(Icons.Filled.Home, contentDescription = "Home")
-                                Text("Home")
-                            }
-                        })
-
-                    //Ricerca
-                    NavigationBarItem(
-                        selected = selectedIndex.value == 1,
-                        onClick = { selectedIndex.value = 1 },
-                        icon = {
-                            Column(horizontalAlignment = Alignment.CenterHorizontally) {
-                                Icon(Icons.Filled.Search, contentDescription = "Search")
-                                Text("Search")
-                            }
-                        })
-
-                    //Wishlist
-                    NavigationBarItem(
-                        selected = selectedIndex.value == 2,
-                        onClick = { selectedIndex.value = 2 },
-                        icon = {
-                            Column(horizontalAlignment = Alignment.CenterHorizontally) {
-                                Icon(Icons.Filled.FavoriteBorder, contentDescription = "Wishlist")
-                                Text("Wishlist")
-                            }
-                        })
-
-                    //Utente
-                    NavigationBarItem(
-                        selected = selectedIndex.value == 3,
-                        onClick = { selectedIndex.value = 3 },
-                        icon = {
-                            Column(horizontalAlignment = Alignment.CenterHorizontally) {
-                                Icon(Icons.Filled.Person, contentDescription = "Account")
-                                Text("Account")
-                            }
-                        })
-                }
-            }
-        },
-    ) {
-        innerPadding ->
-        Column(
-            modifier = Modifier
-                .padding(innerPadding),
-            verticalArrangement = Arrangement.spacedBy(16.dp),
-        ) {
-            if(selectedIndex.value == 0) {
-                Text(
-                    modifier = Modifier.padding(8.dp),
-                    text =
-                    """
-                    This is an example of a scaffold. It uses the Scaffold composable's parameters to create a screen with a simple top app bar, bottom app bar, and floating action button.
-
-                    It also contains some basic inner content, such as this text.
-                """.trimIndent(),
-                )
-            }
-            if(selectedIndex.value == 1) {}
-            if(selectedIndex.value == 2) {}
-            if(selectedIndex.value == 3) {
-                showLogin.value = true;
-                LoginActivity(
-                    viewModel = loginViewModel,
-                    onDismissRequest = {
-                        showLogin.value = false
-                        selectedIndex.value = 0
-                    },
-                    onLoginSuccess = {
-
-                    },
-                    onRegisterSuccess = {
-
-                    },
-                )
-            }
-        }
-    }
-}
-
-@Composable
-fun decodeUriAsBitmap(uri: Uri?): Bitmap? {
-    val context: Context = LocalContext.current
-    var bitmap: Bitmap? = null
-    bitmap = try {
-        BitmapFactory.decodeStream(
-            context
-                .contentResolver.openInputStream(uri!!)
-        )
-    } catch (e: FileNotFoundException) {
-        e.printStackTrace()
-        return null
-    }
-    return bitmap
-}
-
-@Composable
-fun showAlert(title: String, description: String, onDialogClosed: () -> Unit) {
-    AlertDialog(onDismissRequest = {
-        onDialogClosed()
-    },
-        title = {
-            Text(text = title)
-        },
-        text = {
-            Text(text = description)
-        }, confirmButton = {
-            Button(
-                onClick = {
-                    onDialogClosed()
-                }) {
-                Text("Close")
-            }
-        }
-    )
-}
\ No newline at end of file
diff --git a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/activity/AccountActivity.kt b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/activity/AccountActivity.kt
index 581763b..e5a187b 100644
--- a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/activity/AccountActivity.kt
+++ b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/activity/AccountActivity.kt
@@ -1,2 +1,358 @@
 package it.unical.informatica.ea.sefora_frontend.activity
 
+import android.annotation.SuppressLint
+import androidx.activity.compose.rememberLauncherForActivityResult
+import androidx.activity.result.contract.ActivityResultContracts
+import androidx.activity.result.launch
+import androidx.compose.foundation.Image
+import androidx.compose.foundation.layout.Arrangement
+import androidx.compose.foundation.layout.Column
+import androidx.compose.foundation.layout.Row
+import androidx.compose.foundation.layout.Spacer
+import androidx.compose.foundation.layout.fillMaxHeight
+import androidx.compose.foundation.layout.fillMaxWidth
+import androidx.compose.foundation.layout.height
+import androidx.compose.foundation.layout.padding
+import androidx.compose.foundation.layout.size
+import androidx.compose.foundation.layout.width
+import androidx.compose.foundation.rememberScrollState
+import androidx.compose.foundation.shape.CircleShape
+import androidx.compose.foundation.text.KeyboardOptions
+import androidx.compose.foundation.verticalScroll
+import androidx.compose.material.icons.Icons
+import androidx.compose.material.icons.filled.AccountCircle
+import androidx.compose.material3.Button
+import androidx.compose.material3.CircularProgressIndicator
+import androidx.compose.material3.HorizontalDivider
+import androidx.compose.material3.Icon
+import androidx.compose.material3.OutlinedTextField
+import androidx.compose.material3.Text
+import androidx.compose.runtime.Composable
+import androidx.compose.runtime.LaunchedEffect
+import androidx.compose.runtime.collectAsState
+import androidx.compose.runtime.getValue
+import androidx.compose.runtime.mutableStateOf
+import androidx.compose.runtime.remember
+import androidx.compose.ui.Alignment
+import androidx.compose.ui.Modifier
+import androidx.compose.ui.draw.clip
+import androidx.compose.ui.graphics.Color
+import androidx.compose.ui.graphics.asImageBitmap
+import androidx.compose.ui.text.input.KeyboardType
+import androidx.compose.ui.unit.dp
+import androidx.hilt.navigation.compose.hiltViewModel
+import it.unical.informatica.ea.sefora_frontend.models.AccountDto
+import it.unical.informatica.ea.sefora_frontend.viewmodel.AccountViewModel
+import it.unical.informatica.ea.sefora_frontend.viewmodel.LoginViewModel
+import kotlinx.coroutines.Dispatchers
+
+@SuppressLint("StateFlowValueCalledInComposition")
+@Composable
+fun AccountActivity(
+    account: AccountDto,
+    onDismissRequest: () -> Unit
+) {
+    val viewModel: AccountViewModel = hiltViewModel()
+    val loginViewModel: LoginViewModel = hiltViewModel()
+    val accountState by viewModel.accountState.collectAsState()
+    val updateProfile = remember { mutableStateOf(false) }
+    val showSuccessAlert = remember { mutableStateOf(false) }
+    val showAddProductActivity = remember { mutableStateOf(false) }
+    val showAdminActivity = remember { mutableStateOf(false) }
+    val showOrders = remember { mutableStateOf(false) }
+
+    val profilePicture = rememberLauncherForActivityResult(ActivityResultContracts.TakePicturePreview()) {
+        viewModel.onProfilePicChanged(it)
+    }
+
+    val isLoading by viewModel.isLoading
+    val firstNameError = viewModel.firstNameError
+    val lastNameError = viewModel.lastNameError
+    val emailError = viewModel.emailError
+    val phoneError = viewModel.phoneError
+
+    LaunchedEffect(Dispatchers.IO) {
+        accountState.firstName = account.firstname
+        accountState.lastName = account.lastname
+        accountState.email = account.email
+        accountState.phone = account.phone ?: ""
+    }
+
+    if (isLoading) {
+        Column(
+            modifier = Modifier
+                .fillMaxWidth()
+                .fillMaxHeight(),
+            verticalArrangement = Arrangement.Center,
+            horizontalAlignment = Alignment.CenterHorizontally
+        ) {
+            CircularProgressIndicator()
+        }
+    } else if(!showAddProductActivity.value || !showAdminActivity.value) {
+        Column(modifier = Modifier
+            .padding(16.dp)
+            .verticalScroll(rememberScrollState()), verticalArrangement = Arrangement.spacedBy(16.dp)) {
+            // Profile Image or Default Icon
+            account.profileImage?.let {
+                Image(
+                    bitmap = it.asImageBitmap(),
+                    contentDescription = "Profile Picture",
+                    modifier = Modifier
+                        .size(128.dp)
+                        .clip(CircleShape)
+                        .padding(5.dp)
+                )
+            } ?: Icon(
+                Icons.Filled.AccountCircle,
+                contentDescription = "Default Profile Picture",
+                modifier = Modifier
+                    .size(128.dp)
+                    .padding(5.dp)
+            )
+
+            Spacer(modifier = Modifier.height(5.dp))
+            if (!updateProfile.value) {
+                Text(
+                    text = "Name: " + account.firstname
+                )
+                Text(
+                    text = "Surname: " + account.lastname
+                )
+                Text(
+                    text = "Email: " + account.email
+                )
+                Text(
+                    text = "Phone: " + account.phone
+                )
+                Row(
+                    modifier = Modifier.fillMaxWidth(),
+                    horizontalArrangement = Arrangement.SpaceEvenly
+                ) {
+                    Button(
+                        onClick = { updateProfile.value = true },
+                        modifier = Modifier.weight(1f)
+                    ) {
+                        Text("Update Profile")
+                    }
+
+                    Spacer(modifier = Modifier.width(8.dp))
+
+                    Button(
+                        onClick = {
+                            loginViewModel.logout()
+                            onDismissRequest()
+                        },
+                        modifier = Modifier.weight(1f)
+                    ) {
+                        Text("Logout")
+                    }
+                }
+                Button(
+                    onClick = { showOrders.value = true },
+                    modifier = Modifier.fillMaxWidth()
+                ) {
+                    Text("Show orders")
+                }
+
+                if(account.role == AccountDto.Role.ADMIN) {
+                    HorizontalDivider()
+
+                    Row(
+                        modifier = Modifier.fillMaxWidth(),
+                        horizontalArrangement = Arrangement.SpaceEvenly
+                    ) {
+                        Button(
+                            onClick = { showAddProductActivity.value = true },
+                        ) {
+                            Text("Add Product")
+                        }
+
+                        Spacer(modifier = Modifier.height(5.dp))
+
+                        Button(
+                            onClick = { showAdminActivity.value = true },
+                        ) {
+                            Text("Admin Panel")
+                        }
+                    }
+                }
+
+            } else {
+                OutlinedTextField(
+                    value = accountState.firstName.isBlank()
+                        .let { if (it) account.firstname else accountState.firstName },
+                    onValueChange = { viewModel.onFirstNameChanged(it) },
+                    label = { Text("First Name") },
+                    isError = firstNameError != null,
+                    modifier = Modifier.fillMaxWidth(),
+                )
+                if (firstNameError != null) {
+                    Text(text = firstNameError, color = Color.Red)
+                }
+
+                OutlinedTextField(
+                    value = accountState.lastName.isBlank()
+                        .let { if (it) account.lastname else accountState.lastName },
+                    onValueChange = { viewModel.onLastNameChanged(it) },
+                    label = { Text("Last Name") },
+                    isError = lastNameError != null,
+                    modifier = Modifier.fillMaxWidth()
+                )
+                if (lastNameError != null) {
+                    Text(text = lastNameError, color = Color.Red)
+                }
+
+                OutlinedTextField(
+                    value = accountState.email.isBlank()
+                        .let { if (it) account.email else accountState.email },
+                    onValueChange = { viewModel.onEmailChanged(it) },
+                    label = { Text("Email") },
+                    isError = emailError != null,
+                    modifier = Modifier.fillMaxWidth()
+                )
+                if (emailError != null) {
+                    Text(text = emailError, color = Color.Red)
+                }
+
+                OutlinedTextField(
+                    value = accountState.phone.isBlank()
+                        .let { if (it && account.phone != null) account.phone!! else accountState.phone },
+                    onValueChange = { viewModel.onPhoneChanged(it) },
+                    label = { Text("Phone") },
+                    isError = phoneError != null,
+                    modifier = Modifier.fillMaxWidth()
+                )
+                if (phoneError != null) {
+                    Text(text = phoneError, color = Color.Red)
+                }
+
+                Button(
+                    onClick = {
+                        profilePicture.launch()
+                        if(accountState.profilePic != null) {
+                            viewModel.updateImage(
+                                image = accountState.profilePic!!,
+                                id = account.id!!,
+                                firstName = account.firstname,
+                                email = account.email
+                            ) {
+                                showSuccessAlert.value = true
+                            }
+                        }
+                    },
+                    modifier = Modifier.fillMaxWidth()) {
+                    Text("Upload Profile Picture")
+                }
+
+                Button(
+                    onClick = {
+                        viewModel.updateAccount(
+                            id = account.id!!,
+                            role = account.role,
+                            banned = account.banned,
+                            image = account.profileImage
+                        ) { showSuccessAlert.value = true }
+                    },
+                    modifier = Modifier.fillMaxWidth()
+                ) {
+                    Text("Update Account")
+                }
+                if (viewModel.error != null) {
+                    Text(viewModel.error!!, color = Color.Red)
+                }
+
+                Spacer(modifier = Modifier.height(5.dp))
+
+                HorizontalDivider()
+
+                Spacer(modifier = Modifier.height(5.dp))
+
+                OutlinedTextField(
+                    value = accountState.oldPassword,
+                    onValueChange = { viewModel.onOldPasswordChanged(it) },
+                    label = { Text("Current password") },
+                    isError = viewModel.oldPasswordError != null,
+                    modifier = Modifier.fillMaxWidth(),
+                    keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Password)
+                )
+                if (viewModel.oldPasswordError != null) {
+                    Text(text = viewModel.oldPasswordError!!, color = Color.Red)
+                }
+
+                OutlinedTextField(
+                    value = accountState.newPassword,
+                    onValueChange = { viewModel.onNewPasswordChanged(it) },
+                    label = { Text("New password") },
+                    isError = viewModel.newPasswordError != null,
+                    modifier = Modifier.fillMaxWidth(),
+                    keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Password)
+                )
+                if (viewModel.newPasswordError != null) {
+                    Text(text = viewModel.newPasswordError!!, color = Color.Red)
+                }
+
+                OutlinedTextField(
+                    value = accountState.confirmPassword,
+                    onValueChange = { viewModel.onConfirmPasswordChanged(it) },
+                    label = { Text("Confirm password") },
+                    isError = viewModel.confirmPasswordError != null,
+                    modifier = Modifier.fillMaxWidth(),
+                    keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Password)
+                )
+                if (viewModel.confirmPasswordError != null) {
+                    Text(text = viewModel.confirmPasswordError!!, color = Color.Red)
+                }
+
+                Button(
+                    onClick = { viewModel.updatePassword(accountState.oldPassword, accountState.newPassword, accountState.confirmPassword) {
+                        showSuccessAlert.value = true
+                    } },
+                    modifier = Modifier.fillMaxWidth()
+                ) {
+                    Text("Update Password")
+                }
+
+                Button(
+                    onClick = { updateProfile.value = false },
+                    modifier = Modifier.fillMaxWidth()
+                ) {
+                    Text("Cancel")
+                }
+            }
+        }
+    }
+
+    if(showSuccessAlert.value) {
+        showAlert("Done!", "Account updated successfully") {
+            showSuccessAlert.value = false
+            updateProfile.value = false
+            account.phone = accountState.phone
+            account.email = accountState.email
+            account.firstname = accountState.firstName
+            account.lastname = accountState.lastName
+            account.profileImage = accountState.profilePic
+            accountState.newPassword = ""
+            accountState.oldPassword = ""
+            accountState.confirmPassword = ""
+        }
+    }
+
+    if(showAddProductActivity.value) {
+        AddProductActivity {
+            showAddProductActivity.value = false
+        }
+    }
+
+    if(showAdminActivity.value) {
+        AdminActivity {
+            showAdminActivity.value = false
+        }
+    }
+
+    if(showOrders.value) {
+        PurchaseActivity {
+            showOrders.value = false
+        }
+    }
+}
+
diff --git a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/activity/AddProductActivity.kt b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/activity/AddProductActivity.kt
index 581763b..f1fb5c8 100644
--- a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/activity/AddProductActivity.kt
+++ b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/activity/AddProductActivity.kt
@@ -1,2 +1,199 @@
 package it.unical.informatica.ea.sefora_frontend.activity
 
+
+import androidx.activity.compose.rememberLauncherForActivityResult
+import androidx.activity.result.contract.ActivityResultContracts
+import androidx.activity.result.launch
+import androidx.compose.foundation.Image
+import androidx.compose.foundation.layout.Column
+import androidx.compose.foundation.layout.Spacer
+import androidx.compose.foundation.layout.fillMaxSize
+import androidx.compose.foundation.layout.fillMaxWidth
+import androidx.compose.foundation.layout.height
+import androidx.compose.foundation.layout.padding
+import androidx.compose.foundation.layout.size
+import androidx.compose.foundation.text.KeyboardOptions
+import androidx.compose.material3.Button
+import androidx.compose.material3.DropdownMenu
+import androidx.compose.material3.DropdownMenuItem
+import androidx.compose.material3.OutlinedTextField
+import androidx.compose.material3.Text
+import androidx.compose.runtime.Composable
+import androidx.compose.runtime.collectAsState
+import androidx.compose.runtime.getValue
+import androidx.compose.runtime.mutableStateOf
+import androidx.compose.runtime.remember
+import androidx.compose.ui.Alignment
+import androidx.compose.ui.Modifier
+import androidx.compose.ui.graphics.Color
+import androidx.compose.ui.graphics.asImageBitmap
+import androidx.compose.ui.text.input.KeyboardType
+import androidx.compose.ui.unit.dp
+import androidx.hilt.navigation.compose.hiltViewModel
+import it.unical.informatica.ea.sefora_frontend.viewmodel.AddProductViewModel
+import it.unical.informatica.ea.sefora_frontend.models.ProductDto.Category
+
+@Composable
+fun AddProductActivity(
+    onDismiss: () -> Unit,
+) {
+    val viewModel: AddProductViewModel = hiltViewModel()
+    val productState by viewModel.productState.collectAsState()
+    val showError = remember { mutableStateOf(false) }
+    val showSuccess = remember { mutableStateOf(false) }
+
+    val imageProduct = rememberLauncherForActivityResult(ActivityResultContracts.TakePicturePreview()) {
+        viewModel.onImageProductChanged(it)
+    }
+
+    val expanded = remember { mutableStateOf(false) }
+
+    val nameError = viewModel.nameError
+    val categoryError = viewModel.categoryError
+    val descriptionError = viewModel.descriptionError
+    val priceError = viewModel.priceError
+
+    Column(
+        modifier = Modifier
+            .fillMaxSize()
+            .padding(16.dp),
+        horizontalAlignment = Alignment.CenterHorizontally
+    ) {
+        Text(
+            text = "Add New Product",
+            modifier = Modifier.padding(bottom = 16.dp)
+        )
+
+        OutlinedTextField(
+            value = productState.name,
+            onValueChange = { viewModel.onNameChanged(it) },
+            label = { Text("Product Name") },
+            isError = nameError != null,
+            modifier = Modifier
+                .fillMaxWidth()
+                .padding(bottom = 8.dp)
+        )
+        if (nameError != null) {
+            Text(text = nameError, color = Color.Red)
+        }
+
+        // Use a Button instead of TextField to trigger Dropdown
+        Button(
+            onClick = { expanded.value = true },
+            modifier = Modifier.fillMaxWidth(),
+        ) {
+            Text(text = productState.category?.value ?: "Select Category")
+        }
+
+        DropdownMenu(
+            expanded = expanded.value,
+            onDismissRequest = { expanded.value = false },
+            modifier = Modifier.fillMaxWidth()
+        ) {
+            Category.entries.forEach { categoryItem ->
+                DropdownMenuItem(
+                    text = { Text(categoryItem.value) },
+                    onClick = {
+                        viewModel.onCategoryChanged(categoryItem)
+                        expanded.value = false
+                    }
+                )
+            }
+        }
+        if (categoryError != null) {
+            Text(text = categoryError, color = Color.Red)
+        }
+
+        OutlinedTextField(
+            value = productState.description,
+            onValueChange = { viewModel.onDescriptionChanged(it) },
+            label = { Text("Description") },
+            isError = descriptionError != null,
+            modifier = Modifier
+                .fillMaxWidth()
+                .padding(bottom = 8.dp)
+        )
+        if (descriptionError != null) {
+            Text(text = descriptionError, color = Color.Red)
+        }
+
+        OutlinedTextField(
+            value = productState.price.toString(),
+            onValueChange = { viewModel.onPriceChanged(it.toFloatOrNull() ?: 0f) },
+            label = { Text("Price") },
+            keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number),
+            isError = priceError != null,
+            modifier = Modifier
+                .fillMaxWidth()
+                .padding(bottom = 8.dp)
+        )
+        if (priceError != null) {
+            Text(text = priceError, color = Color.Red)
+        }
+
+        // Image Preview and Button
+        if (productState.imageProduct != null) {
+            Image(
+                bitmap = productState.imageProduct!!.asImageBitmap(),
+                contentDescription = "Product Image",
+                modifier = Modifier
+                    .size(100.dp)
+                    .padding(bottom = 8.dp)
+            )
+        } else {
+            Spacer(modifier = Modifier.height(100.dp))
+        }
+
+        Button(
+            onClick = { imageProduct.launch() },
+            modifier = Modifier
+                .fillMaxWidth()
+                .padding(bottom = 8.dp)
+        ) {
+            Text("Add Image")
+        }
+
+        Button(
+            onClick = {
+                if(nameError != null || categoryError != null || descriptionError != null || priceError != null) {
+                    return@Button
+                }
+                viewModel.createProduct(
+                    name = productState.name,
+                    category = productState.category!!,
+                    description = productState.description,
+                    price = productState.price,
+                    imageProduct = productState.imageProduct,
+                    onSuccess = { showSuccess.value = true },
+                    onFailure = { showError.value = true }
+                )
+            },
+            modifier = Modifier
+                .fillMaxWidth()
+                .padding(bottom = 8.dp)
+        ) {
+            Text("Add Product")
+        }
+
+        Button(
+            onClick = onDismiss,
+            modifier = Modifier.fillMaxWidth()
+        ) {
+            Text("Go back")
+        }
+    }
+
+    if (showSuccess.value) {
+        showAlert("Done!", "Product added successfully!") {
+            showSuccess.value = false
+        }
+    }
+
+    if (showError.value) {
+        showAlert("Server error", "Failed to add product, please retry later.") {
+            showError.value = false
+        }
+    }
+}
+
+
diff --git a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/activity/HomeScreen.kt b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/activity/HomeScreen.kt
index 581763b..d7e4a1f 100644
--- a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/activity/HomeScreen.kt
+++ b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/activity/HomeScreen.kt
@@ -1,2 +1,128 @@
 package it.unical.informatica.ea.sefora_frontend.activity
 
+import androidx.compose.foundation.Image
+import androidx.compose.foundation.layout.Arrangement
+import androidx.compose.foundation.layout.Column
+import androidx.compose.foundation.layout.Row
+import androidx.compose.foundation.layout.Spacer
+import androidx.compose.foundation.layout.aspectRatio
+import androidx.compose.foundation.layout.fillMaxHeight
+import androidx.compose.foundation.layout.fillMaxWidth
+import androidx.compose.foundation.layout.height
+import androidx.compose.foundation.layout.padding
+import androidx.compose.foundation.lazy.LazyColumn
+import androidx.compose.foundation.lazy.items
+import androidx.compose.material3.Card
+import androidx.compose.material3.CardDefaults
+import androidx.compose.material3.CircularProgressIndicator
+import androidx.compose.material3.Surface
+import androidx.compose.material3.Text
+import androidx.compose.runtime.Composable
+import androidx.compose.runtime.LaunchedEffect
+import androidx.compose.runtime.MutableState
+import androidx.compose.runtime.getValue
+import androidx.compose.runtime.mutableStateOf
+import androidx.compose.runtime.remember
+import androidx.compose.ui.Alignment
+import androidx.compose.ui.Modifier
+import androidx.compose.ui.graphics.Color
+import androidx.compose.ui.graphics.asImageBitmap
+import androidx.compose.ui.layout.ContentScale
+import androidx.compose.ui.text.font.FontWeight
+import androidx.compose.ui.unit.dp
+import androidx.compose.ui.unit.sp
+import androidx.hilt.navigation.compose.hiltViewModel
+import it.unical.informatica.ea.sefora_frontend.models.ProductDto
+import it.unical.informatica.ea.sefora_frontend.viewmodel.HomeScreenViewModel
+import kotlinx.coroutines.Dispatchers
+
+@Composable
+fun HomeScreen() {
+    val viewModel: HomeScreenViewModel = hiltViewModel()
+    val openArticolo: MutableState<Boolean> = remember { mutableStateOf(false) }
+    val selectedArticolo: MutableState<ProductDto?> = remember { mutableStateOf(null) }
+
+    val textStyle= androidx.compose.ui.text.TextStyle(
+        fontSize = 20.sp,
+        fontWeight = FontWeight.Bold,
+        color = Color.Black
+    )
+
+    val isLoading by viewModel.isLoading
+
+    LaunchedEffect(Dispatchers.IO) {
+        viewModel.getArticoli()
+    }
+
+    if (isLoading) {
+        Column(
+            modifier = Modifier
+                .fillMaxWidth()
+                .fillMaxHeight(),
+            verticalArrangement = Arrangement.Center,
+            horizontalAlignment = Alignment.CenterHorizontally
+        ) {
+            CircularProgressIndicator()
+        }
+    } else {
+        Surface {
+            Column {
+                Spacer(modifier = Modifier.height(15.dp))
+
+                Row(
+                    modifier = Modifier.fillMaxWidth(),
+                    horizontalArrangement = Arrangement.Center,
+                    verticalAlignment = Alignment.CenterVertically
+                ) {
+                    Text(text = "Welcome to Sefora", style = textStyle)
+                }
+
+                Spacer(modifier = Modifier.height(10.dp))
+
+                LazyColumn(
+                    verticalArrangement = Arrangement.SpaceEvenly,
+                    horizontalAlignment = Alignment.CenterHorizontally
+                ) {
+                    items(viewModel.allProductsState.value.articoli) { articolo ->
+                        Card(
+                            onClick = {
+                                openArticolo.value = true
+                                selectedArticolo.value = articolo
+                            },
+                            elevation = CardDefaults.cardElevation(defaultElevation = 5.dp),
+                            modifier = Modifier
+                                .fillMaxWidth()
+                                .padding(20.dp)
+                        ) {
+                            Column {
+                                Image(
+                                    bitmap = articolo.imageProduct!!.asImageBitmap(),
+                                    contentDescription = "Image of product: ${articolo.name}",
+                                    contentScale = ContentScale.FillWidth,
+                                    modifier = Modifier
+                                        .aspectRatio(1f)
+                                )
+                                Row(
+                                    modifier = Modifier.padding(10.dp)
+                                ) {
+                                    Column {
+                                        Text(text = articolo.name)
+                                    }
+                                    Spacer(modifier = Modifier.weight(1f))
+                                    Column {
+                                        Text(text = "${articolo.price}€")
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+    if(openArticolo.value) {
+        ProductActivity(selectedArticolo.value!!) {
+            openArticolo.value = false
+        }
+    }
+}
\ No newline at end of file
diff --git a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/activity/LoginActivity.kt b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/activity/LoginActivity.kt
index 4135104..230007c 100644
--- a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/activity/LoginActivity.kt
+++ b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/activity/LoginActivity.kt
@@ -8,8 +8,21 @@ import androidx.compose.foundation.text.KeyboardOptions
 import androidx.compose.material.icons.Icons
 import androidx.compose.material.icons.filled.Visibility
 import androidx.compose.material.icons.filled.VisibilityOff
-import androidx.compose.material3.*
-import androidx.compose.runtime.*
+import androidx.compose.material3.Button
+import androidx.compose.material3.ExperimentalMaterial3Api
+import androidx.compose.material3.Icon
+import androidx.compose.material3.IconButton
+import androidx.compose.material3.MaterialTheme
+import androidx.compose.material3.ModalBottomSheet
+import androidx.compose.material3.OutlinedTextField
+import androidx.compose.material3.Text
+import androidx.compose.material3.TextButton
+import androidx.compose.material3.rememberModalBottomSheetState
+import androidx.compose.runtime.Composable
+import androidx.compose.runtime.getValue
+import androidx.compose.runtime.mutableStateOf
+import androidx.compose.runtime.remember
+import androidx.compose.runtime.setValue
 import androidx.compose.ui.Alignment
 import androidx.compose.ui.Modifier
 import androidx.compose.ui.text.input.KeyboardType
@@ -17,13 +30,6 @@ import androidx.compose.ui.text.input.PasswordVisualTransformation
 import androidx.compose.ui.text.input.VisualTransformation
 import androidx.compose.ui.unit.dp
 import it.unical.informatica.ea.sefora_frontend.viewmodel.LoginViewModel
-import okhttp3.*
-import okhttp3.MediaType.Companion.toMediaType
-import okhttp3.RequestBody.Companion.toRequestBody
-import org.json.JSONObject
-import java.io.IOException
-
-// ... (other imports)
 
 @OptIn(ExperimentalMaterial3Api::class)
 @Composable
@@ -37,6 +43,7 @@ fun LoginActivity(
     var passwordVisible by remember { mutableStateOf(false) }
     var confirmPasswordVisible by remember { mutableStateOf(false) }
 
+
     ModalBottomSheet(
         onDismissRequest = onDismissRequest,
         sheetState = sheetState,
@@ -150,44 +157,4 @@ fun InputTextField(
         visualTransformation = visualTransformation,
         trailingIcon = trailingIcon
     )
-}
-
-fun performRegistration(viewModel: LoginViewModel, onRegisterSuccess: () -> Unit) {
-    // Create a JSON object with the registration details.
-    val jsonObject = JSONObject().apply {
-        put("email", viewModel.email)
-        put("password", viewModel.password)
-    }
-
-    // Define the media type for the JSON payload.
-    val mediaType = "application/json; charset=utf-8".toMediaType()
-
-    // Create the request body with the JSON object and the correct media type.
-    val requestBody = jsonObject.toString().toRequestBody(mediaType)
-
-    // Build the request with the URL and request body.
-    val request = Request.Builder()
-        .url("https://yourapi.com/register")  // Replace with your actual registration URL.
-        .post(requestBody)
-        .build()
-
-    // Initialize OkHttp client.
-    val client = OkHttpClient()
-
-    // Asynchronously send the request.
-    client.newCall(request).enqueue(object : Callback {
-        override fun onFailure(call: Call, e: IOException) {
-            // Handle request failure by updating the UI with the error message.
-            viewModel.error = "Registration Failed: ${e.message}"
-        }
-
-        override fun onResponse(call: Call, response: Response) {
-            // Handle successful response or show an error based on the response.
-            if (response.isSuccessful) {
-                onRegisterSuccess()  // Trigger success callback.
-            } else {
-                viewModel.error = "Registration Failed: ${response.message}"
-            }
-        }
-    })
-}
+}
\ No newline at end of file
diff --git a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/activity/OrderActivity.kt b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/activity/OrderActivity.kt
deleted file mode 100644
index 581763b..0000000
--- a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/activity/OrderActivity.kt
+++ /dev/null
@@ -1,2 +0,0 @@
-package it.unical.informatica.ea.sefora_frontend.activity
-
diff --git a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/activity/ProductActivity.kt b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/activity/ProductActivity.kt
index 581763b..9a638dd 100644
--- a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/activity/ProductActivity.kt
+++ b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/activity/ProductActivity.kt
@@ -1,2 +1,143 @@
 package it.unical.informatica.ea.sefora_frontend.activity
 
+import android.annotation.SuppressLint
+import androidx.compose.foundation.Image
+import androidx.compose.foundation.layout.Arrangement
+import androidx.compose.foundation.layout.Column
+import androidx.compose.foundation.layout.Spacer
+import androidx.compose.foundation.layout.fillMaxWidth
+import androidx.compose.foundation.layout.height
+import androidx.compose.foundation.layout.padding
+import androidx.compose.foundation.layout.size
+import androidx.compose.material3.Button
+import androidx.compose.material3.ExperimentalMaterial3Api
+import androidx.compose.material3.ModalBottomSheet
+import androidx.compose.material3.Text
+import androidx.compose.material3.rememberModalBottomSheetState
+import androidx.compose.runtime.Composable
+import androidx.compose.runtime.mutableStateOf
+import androidx.compose.runtime.remember
+import androidx.compose.runtime.rememberCoroutineScope
+import androidx.compose.ui.Alignment
+import androidx.compose.ui.Modifier
+import androidx.compose.ui.graphics.asImageBitmap
+import androidx.compose.ui.text.font.FontWeight
+import androidx.compose.ui.unit.dp
+import androidx.compose.ui.unit.sp
+import androidx.hilt.navigation.compose.hiltViewModel
+import it.unical.informatica.ea.sefora_frontend.models.ProductDto
+import it.unical.informatica.ea.sefora_frontend.viewmodel.AccountViewModel
+import it.unical.informatica.ea.sefora_frontend.viewmodel.PurchaseViewModel
+import it.unical.informatica.ea.sefora_frontend.viewmodel.WishlistViewModel
+
+@OptIn(ExperimentalMaterial3Api::class)
+@SuppressLint("StateFlowValueCalledInComposition")
+@Composable
+fun ProductActivity(
+    productDto: ProductDto,
+    onDismissRequest: () -> Unit
+) {
+    val viewModel: AccountViewModel = hiltViewModel()
+    val wishlistViewModel: WishlistViewModel = hiltViewModel()
+    val purchaseViewModel: PurchaseViewModel = hiltViewModel()
+    val sheetState = rememberModalBottomSheetState(skipPartiallyExpanded = true)
+    val showSuccessAlert = remember { mutableStateOf(false) }
+
+    val coroutineScope = rememberCoroutineScope()
+
+    ModalBottomSheet(
+        onDismissRequest = onDismissRequest,
+        sheetState = sheetState,
+    ) {
+        Column(
+            modifier = Modifier
+                .fillMaxWidth()
+                .padding(16.dp),
+            verticalArrangement = Arrangement.spacedBy(16.dp),
+            horizontalAlignment = Alignment.CenterHorizontally
+        ) {
+            // Product Image
+            productDto.imageProduct?.let {
+                Image(
+                    bitmap = it.asImageBitmap(),
+                    contentDescription = "Product Image",
+                    modifier = Modifier
+                        .size(150.dp)
+                        .padding(bottom = 16.dp)
+                )
+            }
+
+            // Product Name
+            Text(
+                text = productDto.name,
+                fontSize = 24.sp,
+                fontWeight = FontWeight.Bold,
+                modifier = Modifier.padding(bottom = 8.dp)
+            )
+
+            // Product Category
+            Text(
+                text = "Category: ${productDto.category.value}",
+                fontSize = 18.sp,
+                fontWeight = FontWeight.Medium,
+                modifier = Modifier.padding(bottom = 8.dp)
+            )
+
+            // Product Description
+            Text(
+                text = productDto.description ?: "No description available",
+                fontSize = 16.sp,
+                modifier = Modifier.padding(bottom = 8.dp)
+            )
+
+            // Product Price
+            productDto.price?.let { price ->
+                Text(
+                    text = "Price: $${price}",
+                    fontSize = 18.sp,
+                    fontWeight = FontWeight.Medium,
+                    modifier = Modifier.padding(bottom = 8.dp)
+                )
+            }
+
+            Spacer(modifier = Modifier.height(16.dp))
+
+            // Add to wishlist button
+            Button(
+                onClick = {
+                    wishlistViewModel.addProductToWishlist(productId = productDto.id!!) {
+                        showSuccessAlert.value = true
+                    }
+                },
+                modifier = Modifier.fillMaxWidth()
+            ) {
+                Text(text = "Add to wishlist")
+            }
+
+            Button(
+                onClick = {
+                     purchaseViewModel.convertProductToPurchase(productId = productDto.id!!) {
+                        showSuccessAlert.value = true
+                    }
+                },
+                modifier = Modifier.fillMaxWidth()
+            ) {
+                Text(text = "Buy now")
+            }
+            // Close Button
+            Button(
+                onClick = onDismissRequest,
+                modifier = Modifier.fillMaxWidth()
+            ) {
+                Text(text = "Close")
+            }
+        }
+    }
+
+    if(showSuccessAlert.value) {
+        showAlert("Done!", "Action executed successfully!") {
+            showSuccessAlert.value = false
+            onDismissRequest()
+        }
+    }
+}
\ No newline at end of file
diff --git a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/apis/AccountControllerApi.kt b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/apis/AccountControllerApi.kt
index c41ae0b..a4190c2 100644
--- a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/apis/AccountControllerApi.kt
+++ b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/apis/AccountControllerApi.kt
@@ -13,39 +13,48 @@
     "UnusedImport",
 )
 
-package org.openapitools.client.apis
+package it.unical.informatica.ea.sefora_frontend.apis
 
+import it.unical.informatica.ea.sefora_frontend.BuildConfig
+import it.unical.informatica.ea.sefora_frontend.auth.TokenManager
+import kotlinx.coroutines.Dispatchers
+import kotlinx.coroutines.runBlocking
+import kotlinx.coroutines.withContext
 import okhttp3.HttpUrl
 import okhttp3.OkHttpClient
-import org.openapitools.client.infrastructure.ApiClient
-import org.openapitools.client.infrastructure.ApiResponse
-import org.openapitools.client.infrastructure.ClientError
-import org.openapitools.client.infrastructure.ClientException
-import org.openapitools.client.infrastructure.MultiValueMap
-import org.openapitools.client.infrastructure.RequestConfig
-import org.openapitools.client.infrastructure.RequestMethod
-import org.openapitools.client.infrastructure.ResponseType
-import org.openapitools.client.infrastructure.ServerError
-import org.openapitools.client.infrastructure.ServerException
-import org.openapitools.client.infrastructure.Success
-import org.openapitools.client.models.AccountDto
-import org.openapitools.client.models.AuthenticationRequest
-import org.openapitools.client.models.AuthenticationResponse
-import org.openapitools.client.models.ChangePasswordRequest
-import org.openapitools.client.models.RegisterRequest
+import it.unical.informatica.ea.sefora_frontend.infrastructure.ApiClient
+import it.unical.informatica.ea.sefora_frontend.infrastructure.ApiResponse
+import it.unical.informatica.ea.sefora_frontend.infrastructure.ClientError
+import it.unical.informatica.ea.sefora_frontend.infrastructure.ClientException
+import it.unical.informatica.ea.sefora_frontend.infrastructure.MultiValueMap
+import it.unical.informatica.ea.sefora_frontend.infrastructure.RequestConfig
+import it.unical.informatica.ea.sefora_frontend.infrastructure.RequestMethod
+import it.unical.informatica.ea.sefora_frontend.infrastructure.ResponseType
+import it.unical.informatica.ea.sefora_frontend.infrastructure.ServerError
+import it.unical.informatica.ea.sefora_frontend.infrastructure.ServerException
+import it.unical.informatica.ea.sefora_frontend.infrastructure.Success
+import it.unical.informatica.ea.sefora_frontend.models.AccountDto
+import it.unical.informatica.ea.sefora_frontend.models.AccountShortDto
+import it.unical.informatica.ea.sefora_frontend.models.AuthenticationRequest
+import it.unical.informatica.ea.sefora_frontend.models.AuthenticationResponse
+import it.unical.informatica.ea.sefora_frontend.models.ChangePasswordRequest
+import it.unical.informatica.ea.sefora_frontend.models.RegisterRequest
 import java.io.IOException
+import javax.inject.Inject
 
-class AccountControllerApi(
+class AccountControllerApi (
     basePath: kotlin.String = defaultBasePath,
     client: OkHttpClient = ApiClient.defaultClient,
 ) : ApiClient(basePath, client) {
     companion object {
         @JvmStatic
         val defaultBasePath: String by lazy {
-            System.getProperties().getProperty(ApiClient.baseUrlKey, "http://localhost:8080")
+            System.getProperties().getProperty(ApiClient.baseUrlKey, BuildConfig.SERVER_ADDRESS)
         }
     }
 
+
+
     /**
      *
      *
@@ -65,17 +74,17 @@ class AccountControllerApi(
         ClientException::class,
         ServerException::class,
     )
-    fun authenticate(authenticationRequest: AuthenticationRequest): AuthenticationResponse {
+    suspend fun authenticate(authenticationRequest: AuthenticationRequest): AuthenticationResponse = withContext(Dispatchers.IO) {
         val localVarResponse = authenticateWithHttpInfo(authenticationRequest = authenticationRequest)
 
-        return when (localVarResponse.responseType) {
+        return@withContext when (localVarResponse.responseType) {
             ResponseType.Success -> (localVarResponse as Success<*>).data as AuthenticationResponse
             ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
             ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
             ResponseType.ClientError -> {
                 val localVarError = localVarResponse as ClientError<*>
                 throw ClientException(
-                    "Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}",
+                    "Client error : ${localVarError.statusCode} ${localVarError.message}",
                     localVarError.statusCode,
                     localVarResponse,
                 )
@@ -134,7 +143,7 @@ class AccountControllerApi(
     /**
      *
      *
-     * @param userId
+     * @param accountId
      * @return kotlin.Any
      * @throws IllegalStateException If the request is not correctly configured
      * @throws IOException Rethrows the OkHttp execute method exception
@@ -150,11 +159,11 @@ class AccountControllerApi(
         ClientException::class,
         ServerException::class,
     )
-    fun banUser(userId: kotlin.Long): kotlin.Any {
-        val localVarResponse = banUserWithHttpInfo(userId = userId)
+    fun banAccount(accountId: kotlin.Long, token: String) = runBlocking(Dispatchers.IO) {
+        val localVarResponse = banAccountWithHttpInfo(accountId = accountId, token = token)
 
-        return when (localVarResponse.responseType) {
-            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
+        return@runBlocking when (localVarResponse.responseType) {
+            ResponseType.Success -> (localVarResponse as Success<*>)
             ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
             ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
             ResponseType.ClientError -> {
@@ -179,15 +188,15 @@ class AccountControllerApi(
     /**
      *
      *
-     * @param userId
+     * @param accountId
      * @return ApiResponse<kotlin.Any?>
      * @throws IllegalStateException If the request is not correctly configured
      * @throws IOException Rethrows the OkHttp execute method exception
      */
     @Suppress("UNCHECKED_CAST")
     @Throws(IllegalStateException::class, IOException::class)
-    fun banUserWithHttpInfo(userId: kotlin.Long): ApiResponse<kotlin.Any?> {
-        val localVariableConfig = banUserRequestConfig(userId = userId)
+    fun banAccountWithHttpInfo(accountId: kotlin.Long, token: String): ApiResponse<kotlin.Any?> {
+        val localVariableConfig = banAccountRequestConfig(accountId = accountId, token = token)
 
         return request<Unit, kotlin.Any>(
             localVariableConfig,
@@ -195,19 +204,21 @@ class AccountControllerApi(
     }
 
     /**
-     * To obtain the request config of the operation banUser
+     * To obtain the request config of the operation banAccount
      *
-     * @param userId
+     * @param accountId
      * @return RequestConfig
      */
-    fun banUserRequestConfig(userId: kotlin.Long): RequestConfig<Unit> {
+    fun banAccountRequestConfig(accountId: kotlin.Long, token: String): RequestConfig<Unit> {
         val localVariableBody = null
         val localVariableQuery: MultiValueMap = mutableMapOf()
         val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
 
+        localVariableHeaders["Authorization"] = "Bearer $token"
+
         return RequestConfig(
             method = RequestMethod.PATCH,
-            path = "/api/account/ban/{userId}".replace("{" + "userId" + "}", encodeURIComponent(userId.toString())),
+            path = "/api/account/ban/{accountId}".replace("{" + "accountId" + "}", encodeURIComponent(accountId.toString())),
             query = localVariableQuery,
             headers = localVariableHeaders,
             requiresAuthentication = true,
@@ -234,11 +245,11 @@ class AccountControllerApi(
         ClientException::class,
         ServerException::class,
     )
-    fun changePassword(changePasswordRequest: ChangePasswordRequest): kotlin.Any {
-        val localVarResponse = changePasswordWithHttpInfo(changePasswordRequest = changePasswordRequest)
+    fun changePassword(changePasswordRequest: ChangePasswordRequest, token: String): kotlin.Any = runBlocking(Dispatchers.IO) {
+        val localVarResponse = changePasswordWithHttpInfo(changePasswordRequest = changePasswordRequest, token = token)
 
-        return when (localVarResponse.responseType) {
-            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
+        return@runBlocking when (localVarResponse.responseType) {
+            ResponseType.Success -> (localVarResponse as Success<*>)
             ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
             ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
             ResponseType.ClientError -> {
@@ -270,8 +281,8 @@ class AccountControllerApi(
      */
     @Suppress("UNCHECKED_CAST")
     @Throws(IllegalStateException::class, IOException::class)
-    fun changePasswordWithHttpInfo(changePasswordRequest: ChangePasswordRequest): ApiResponse<kotlin.Any?> {
-        val localVariableConfig = changePasswordRequestConfig(changePasswordRequest = changePasswordRequest)
+    fun changePasswordWithHttpInfo(changePasswordRequest: ChangePasswordRequest, token: String): ApiResponse<kotlin.Any?> {
+        val localVariableConfig = changePasswordRequestConfig(changePasswordRequest = changePasswordRequest, token = token)
 
         return request<ChangePasswordRequest, kotlin.Any>(
             localVariableConfig,
@@ -284,12 +295,14 @@ class AccountControllerApi(
      * @param changePasswordRequest
      * @return RequestConfig
      */
-    fun changePasswordRequestConfig(changePasswordRequest: ChangePasswordRequest): RequestConfig<ChangePasswordRequest> {
+    fun changePasswordRequestConfig(changePasswordRequest: ChangePasswordRequest, token: String): RequestConfig<ChangePasswordRequest> {
         val localVariableBody = changePasswordRequest
         val localVariableQuery: MultiValueMap = mutableMapOf()
         val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
         localVariableHeaders["Content-Type"] = "application/json"
 
+        localVariableHeaders["Authorization"] = "Bearer $token"
+
         return RequestConfig(
             method = RequestMethod.PATCH,
             path = "/api/account",
@@ -303,7 +316,7 @@ class AccountControllerApi(
     /**
      *
      *
-     * @param userId
+     * @param accountId
      * @return kotlin.Any
      * @throws IllegalStateException If the request is not correctly configured
      * @throws IOException Rethrows the OkHttp execute method exception
@@ -319,11 +332,11 @@ class AccountControllerApi(
         ClientException::class,
         ServerException::class,
     )
-    fun deleteUser(userId: kotlin.Long): kotlin.Any {
-        val localVarResponse = deleteUserWithHttpInfo(userId = userId)
+    fun deleteAccount(accountId: kotlin.Long, token: String) = runBlocking(Dispatchers.IO) {
+        val localVarResponse = deleteAccountWithHttpInfo(accountId = accountId, token = token)
 
-        return when (localVarResponse.responseType) {
-            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
+        return@runBlocking when (localVarResponse.responseType) {
+            ResponseType.Success -> (localVarResponse as Success<*>)
             ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
             ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
             ResponseType.ClientError -> {
@@ -348,15 +361,15 @@ class AccountControllerApi(
     /**
      *
      *
-     * @param userId
+     * @param accountId
      * @return ApiResponse<kotlin.Any?>
      * @throws IllegalStateException If the request is not correctly configured
      * @throws IOException Rethrows the OkHttp execute method exception
      */
     @Suppress("UNCHECKED_CAST")
     @Throws(IllegalStateException::class, IOException::class)
-    fun deleteUserWithHttpInfo(userId: kotlin.Long): ApiResponse<kotlin.Any?> {
-        val localVariableConfig = deleteUserRequestConfig(userId = userId)
+    fun deleteAccountWithHttpInfo(accountId: kotlin.Long, token: String): ApiResponse<kotlin.Any?> {
+        val localVariableConfig = deleteAccountRequestConfig(accountId = accountId, token = token)
 
         return request<Unit, kotlin.Any>(
             localVariableConfig,
@@ -364,19 +377,21 @@ class AccountControllerApi(
     }
 
     /**
-     * To obtain the request config of the operation deleteUser
+     * To obtain the request config of the operation deleteAccount
      *
-     * @param userId
+     * @param accountId
      * @return RequestConfig
      */
-    fun deleteUserRequestConfig(userId: kotlin.Long): RequestConfig<Unit> {
+    fun deleteAccountRequestConfig(accountId: kotlin.Long, token: String): RequestConfig<Unit> {
         val localVariableBody = null
         val localVariableQuery: MultiValueMap = mutableMapOf()
         val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
 
+        localVariableHeaders["Authorization"] = "Bearer $token"
+
         return RequestConfig(
             method = RequestMethod.DELETE,
-            path = "/api/account/delete/{userId}".replace("{" + "userId" + "}", encodeURIComponent(userId.toString())),
+            path = "/api/account/delete/{accountId}".replace("{" + "accountId" + "}", encodeURIComponent(accountId.toString())),
             query = localVariableQuery,
             headers = localVariableHeaders,
             requiresAuthentication = true,
@@ -387,6 +402,7 @@ class AccountControllerApi(
     /**
      *
      *
+     * @param accountId
      * @return AccountDto
      * @throws IllegalStateException If the request is not correctly configured
      * @throws IOException Rethrows the OkHttp execute method exception
@@ -402,10 +418,10 @@ class AccountControllerApi(
         ClientException::class,
         ServerException::class,
     )
-    fun getConnectedUser(): AccountDto {
-        val localVarResponse = getConnectedUserWithHttpInfo()
+    fun getAccountById(accountId: kotlin.Long): AccountDto = runBlocking(Dispatchers.IO) {
+        val localVarResponse = getAccountByIdWithHttpInfo(accountId = accountId)
 
-        return when (localVarResponse.responseType) {
+        return@runBlocking when (localVarResponse.responseType) {
             ResponseType.Success -> (localVarResponse as Success<*>).data as AccountDto
             ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
             ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
@@ -431,14 +447,15 @@ class AccountControllerApi(
     /**
      *
      *
+     * @param accountId
      * @return ApiResponse<AccountDto?>
      * @throws IllegalStateException If the request is not correctly configured
      * @throws IOException Rethrows the OkHttp execute method exception
      */
     @Suppress("UNCHECKED_CAST")
     @Throws(IllegalStateException::class, IOException::class)
-    fun getConnectedUserWithHttpInfo(): ApiResponse<AccountDto?> {
-        val localVariableConfig = getConnectedUserRequestConfig()
+    fun getAccountByIdWithHttpInfo(accountId: kotlin.Long): ApiResponse<AccountDto?> {
+        val localVariableConfig = getAccountByIdRequestConfig(accountId = accountId)
 
         return request<Unit, AccountDto>(
             localVariableConfig,
@@ -446,18 +463,19 @@ class AccountControllerApi(
     }
 
     /**
-     * To obtain the request config of the operation getConnectedUser
+     * To obtain the request config of the operation getAccountById
      *
+     * @param accountId
      * @return RequestConfig
      */
-    fun getConnectedUserRequestConfig(): RequestConfig<Unit> {
+    fun getAccountByIdRequestConfig(accountId: kotlin.Long): RequestConfig<Unit> {
         val localVariableBody = null
         val localVariableQuery: MultiValueMap = mutableMapOf()
         val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
 
         return RequestConfig(
             method = RequestMethod.GET,
-            path = "/api/account/current",
+            path = "/api/account/{accountId}".replace("{" + "accountId" + "}", encodeURIComponent(accountId.toString())),
             query = localVariableQuery,
             headers = localVariableHeaders,
             requiresAuthentication = true,
@@ -468,8 +486,7 @@ class AccountControllerApi(
     /**
      *
      *
-     * @param userId
-     * @return AccountDto
+     * @return kotlin.collections.List<AccountShortDto>
      * @throws IllegalStateException If the request is not correctly configured
      * @throws IOException Rethrows the OkHttp execute method exception
      * @throws UnsupportedOperationException If the API returns an informational or redirection response
@@ -477,35 +494,21 @@ class AccountControllerApi(
      * @throws ServerException If the API returns a server error response
      */
     @Suppress("UNCHECKED_CAST")
-    @Throws(
-        IllegalStateException::class,
-        IOException::class,
-        UnsupportedOperationException::class,
-        ClientException::class,
-        ServerException::class,
-    )
-    fun getUserById(userId: kotlin.Long): AccountDto {
-        val localVarResponse = getUserByIdWithHttpInfo(userId = userId)
+    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
+    suspend fun getAllAccounts(token: String) : kotlin.collections.List<AccountShortDto> = withContext(Dispatchers.IO) {
+        val localVarResponse = getAllAccountsWithHttpInfo(token = token)
 
-        return when (localVarResponse.responseType) {
-            ResponseType.Success -> (localVarResponse as Success<*>).data as AccountDto
+        return@withContext when (localVarResponse.responseType) {
+            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<AccountShortDto>
             ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
             ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
             ResponseType.ClientError -> {
                 val localVarError = localVarResponse as ClientError<*>
-                throw ClientException(
-                    "Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}",
-                    localVarError.statusCode,
-                    localVarResponse,
-                )
+                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
             }
             ResponseType.ServerError -> {
                 val localVarError = localVarResponse as ServerError<*>
-                throw ServerException(
-                    "Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}",
-                    localVarError.statusCode,
-                    localVarResponse,
-                )
+                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
             }
         }
     }
@@ -513,46 +516,46 @@ class AccountControllerApi(
     /**
      *
      *
-     * @param userId
-     * @return ApiResponse<AccountDto?>
+     * @return ApiResponse<kotlin.collections.List<AccountShortDto>?>
      * @throws IllegalStateException If the request is not correctly configured
      * @throws IOException Rethrows the OkHttp execute method exception
      */
     @Suppress("UNCHECKED_CAST")
     @Throws(IllegalStateException::class, IOException::class)
-    fun getUserByIdWithHttpInfo(userId: kotlin.Long): ApiResponse<AccountDto?> {
-        val localVariableConfig = getUserByIdRequestConfig(userId = userId)
+    fun getAllAccountsWithHttpInfo(token: String) : ApiResponse<kotlin.collections.List<AccountShortDto>?> {
+        val localVariableConfig = getAllAccountsRequestConfig(token = token)
 
-        return request<Unit, AccountDto>(
-            localVariableConfig,
+        return request<Unit, kotlin.collections.List<AccountShortDto>>(
+            localVariableConfig
         )
     }
 
     /**
-     * To obtain the request config of the operation getUserById
+     * To obtain the request config of the operation getAllAccounts
      *
-     * @param userId
      * @return RequestConfig
      */
-    fun getUserByIdRequestConfig(userId: kotlin.Long): RequestConfig<Unit> {
+    fun getAllAccountsRequestConfig(token: String) : RequestConfig<Unit> {
         val localVariableBody = null
         val localVariableQuery: MultiValueMap = mutableMapOf()
         val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
 
+        localVariableHeaders["Authorization"] = "Bearer $token"
+
         return RequestConfig(
             method = RequestMethod.GET,
-            path = "/api/account/{userId}".replace("{" + "userId" + "}", encodeURIComponent(userId.toString())),
+            path = "/api/account/all",
             query = localVariableQuery,
             headers = localVariableHeaders,
             requiresAuthentication = true,
-            body = localVariableBody,
+            body = localVariableBody
         )
     }
 
     /**
      *
      *
-     * @return kotlin.String
+     * @return AccountDto
      * @throws IllegalStateException If the request is not correctly configured
      * @throws IOException Rethrows the OkHttp execute method exception
      * @throws UnsupportedOperationException If the API returns an informational or redirection response
@@ -567,11 +570,11 @@ class AccountControllerApi(
         ClientException::class,
         ServerException::class,
     )
-    fun loginFailure(): kotlin.String {
-        val localVarResponse = loginFailureWithHttpInfo()
+    fun getConnectedAccount(token: String): AccountDto = runBlocking(Dispatchers.IO) {
+        val localVarResponse = getConnectedAccountWithHttpInfo(token)
 
-        return when (localVarResponse.responseType) {
-            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.String
+        return@runBlocking when (localVarResponse.responseType) {
+            ResponseType.Success -> (localVarResponse as Success<*>).data as AccountDto
             ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
             ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
             ResponseType.ClientError -> {
@@ -596,33 +599,35 @@ class AccountControllerApi(
     /**
      *
      *
-     * @return ApiResponse<kotlin.String?>
+     * @return ApiResponse<AccountDto?>
      * @throws IllegalStateException If the request is not correctly configured
      * @throws IOException Rethrows the OkHttp execute method exception
      */
     @Suppress("UNCHECKED_CAST")
     @Throws(IllegalStateException::class, IOException::class)
-    fun loginFailureWithHttpInfo(): ApiResponse<kotlin.String?> {
-        val localVariableConfig = loginFailureRequestConfig()
+    fun getConnectedAccountWithHttpInfo(token: String): ApiResponse<AccountDto?> {
+        val localVariableConfig = getConnectedAccountRequestConfig(token)
 
-        return request<Unit, kotlin.String>(
+        return request<Unit, AccountDto>(
             localVariableConfig,
         )
     }
 
     /**
-     * To obtain the request config of the operation loginFailure
+     * To obtain the request config of the operation getConnectedAccount
      *
      * @return RequestConfig
      */
-    fun loginFailureRequestConfig(): RequestConfig<Unit> {
+    fun getConnectedAccountRequestConfig(token: String): RequestConfig<Unit> {
         val localVariableBody = null
         val localVariableQuery: MultiValueMap = mutableMapOf()
         val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
 
+        localVariableHeaders["Authorization"] = "Bearer $token"
+
         return RequestConfig(
             method = RequestMethod.GET,
-            path = "/api/account/login-failure",
+            path = "/api/account/current",
             query = localVariableQuery,
             headers = localVariableHeaders,
             requiresAuthentication = true,
@@ -630,10 +635,12 @@ class AccountControllerApi(
         )
     }
 
+
+
     /**
      *
      *
-     * @return kotlin.String
+     * @return kotlin.Any
      * @throws IllegalStateException If the request is not correctly configured
      * @throws IOException Rethrows the OkHttp execute method exception
      * @throws UnsupportedOperationException If the API returns an informational or redirection response
@@ -648,11 +655,11 @@ class AccountControllerApi(
         ClientException::class,
         ServerException::class,
     )
-    fun loginSuccess(): kotlin.String {
-        val localVarResponse = loginSuccessWithHttpInfo()
+    fun logout(token: String) = runBlocking(Dispatchers.IO) {
+        val localVarResponse = logoutWithHttpInfo(token)
 
-        return when (localVarResponse.responseType) {
-            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.String
+        return@runBlocking when (localVarResponse.responseType) {
+            ResponseType.Success -> (localVarResponse as Success<*>)
             ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
             ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
             ResponseType.ClientError -> {
@@ -677,33 +684,35 @@ class AccountControllerApi(
     /**
      *
      *
-     * @return ApiResponse<kotlin.String?>
+     * @return ApiResponse<kotlin.Any?>
      * @throws IllegalStateException If the request is not correctly configured
      * @throws IOException Rethrows the OkHttp execute method exception
      */
     @Suppress("UNCHECKED_CAST")
     @Throws(IllegalStateException::class, IOException::class)
-    fun loginSuccessWithHttpInfo(): ApiResponse<kotlin.String?> {
-        val localVariableConfig = loginSuccessRequestConfig()
+    fun logoutWithHttpInfo(token: String): ApiResponse<kotlin.Any?> {
+        val localVariableConfig = logoutRequestConfig(token)
 
-        return request<Unit, kotlin.String>(
+        return request<Unit, kotlin.Any>(
             localVariableConfig,
         )
     }
 
     /**
-     * To obtain the request config of the operation loginSuccess
+     * To obtain the request config of the operation logout
      *
      * @return RequestConfig
      */
-    fun loginSuccessRequestConfig(): RequestConfig<Unit> {
+    fun logoutRequestConfig(token: String): RequestConfig<Unit> {
         val localVariableBody = null
         val localVariableQuery: MultiValueMap = mutableMapOf()
         val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
 
+        localVariableHeaders["Authorization"] = "Bearer $token"
+
         return RequestConfig(
             method = RequestMethod.GET,
-            path = "/api/account/login-success",
+            path = "/api/account/logout",
             query = localVariableQuery,
             headers = localVariableHeaders,
             requiresAuthentication = true,
@@ -714,6 +723,7 @@ class AccountControllerApi(
     /**
      *
      *
+     * @param accountId
      * @return kotlin.Any
      * @throws IllegalStateException If the request is not correctly configured
      * @throws IOException Rethrows the OkHttp execute method exception
@@ -729,11 +739,11 @@ class AccountControllerApi(
         ClientException::class,
         ServerException::class,
     )
-    fun logout(): kotlin.Any {
-        val localVarResponse = logoutWithHttpInfo()
+    fun makeAdmin(accountId: kotlin.Long, token: String) = runBlocking(Dispatchers.IO) {
+        val localVarResponse = makeAdminWithHttpInfo(accountId = accountId, token = token)
 
-        return when (localVarResponse.responseType) {
-            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
+        return@runBlocking when (localVarResponse.responseType) {
+            ResponseType.Success -> (localVarResponse as Success<*>)
             ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
             ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
             ResponseType.ClientError -> {
@@ -758,14 +768,15 @@ class AccountControllerApi(
     /**
      *
      *
+     * @param accountId
      * @return ApiResponse<kotlin.Any?>
      * @throws IllegalStateException If the request is not correctly configured
      * @throws IOException Rethrows the OkHttp execute method exception
      */
     @Suppress("UNCHECKED_CAST")
     @Throws(IllegalStateException::class, IOException::class)
-    fun logoutWithHttpInfo(): ApiResponse<kotlin.Any?> {
-        val localVariableConfig = logoutRequestConfig()
+    fun makeAdminWithHttpInfo(accountId: kotlin.Long, token: String): ApiResponse<kotlin.Any?> {
+        val localVariableConfig = makeAdminRequestConfig(accountId = accountId, token = token)
 
         return request<Unit, kotlin.Any>(
             localVariableConfig,
@@ -773,18 +784,21 @@ class AccountControllerApi(
     }
 
     /**
-     * To obtain the request config of the operation logout
+     * To obtain the request config of the operation makeAdmin
      *
+     * @param accountId
      * @return RequestConfig
      */
-    fun logoutRequestConfig(): RequestConfig<Unit> {
+    fun makeAdminRequestConfig(accountId: kotlin.Long, token: String): RequestConfig<Unit> {
         val localVariableBody = null
         val localVariableQuery: MultiValueMap = mutableMapOf()
         val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
 
+        localVariableHeaders["Authorization"] = "Bearer $token"
+
         return RequestConfig(
-            method = RequestMethod.GET,
-            path = "/api/account/logout",
+            method = RequestMethod.PATCH,
+            path = "/api/account/makeAdmin/{accountId}".replace("{" + "accountId" + "}", encodeURIComponent(accountId.toString())),
             query = localVariableQuery,
             headers = localVariableHeaders,
             requiresAuthentication = true,
@@ -795,13 +809,14 @@ class AccountControllerApi(
     /**
      *
      *
-     * @return void
+     * @return AuthenticationResponse
      * @throws IllegalStateException If the request is not correctly configured
      * @throws IOException Rethrows the OkHttp execute method exception
      * @throws UnsupportedOperationException If the API returns an informational or redirection response
      * @throws ClientException If the API returns a client error response
      * @throws ServerException If the API returns a server error response
      */
+    @Suppress("UNCHECKED_CAST")
     @Throws(
         IllegalStateException::class,
         IOException::class,
@@ -809,11 +824,11 @@ class AccountControllerApi(
         ClientException::class,
         ServerException::class,
     )
-    fun refreshToken() {
+    fun refreshToken(): AuthenticationResponse = runBlocking(Dispatchers.IO) {
         val localVarResponse = refreshTokenWithHttpInfo()
 
-        return when (localVarResponse.responseType) {
-            ResponseType.Success -> Unit
+        return@runBlocking when (localVarResponse.responseType) {
+            ResponseType.Success -> (localVarResponse as Success<*>).data as AuthenticationResponse
             ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
             ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
             ResponseType.ClientError -> {
@@ -838,15 +853,16 @@ class AccountControllerApi(
     /**
      *
      *
-     * @return ApiResponse<Unit?>
+     * @return ApiResponse<AuthenticationResponse?>
      * @throws IllegalStateException If the request is not correctly configured
      * @throws IOException Rethrows the OkHttp execute method exception
      */
+    @Suppress("UNCHECKED_CAST")
     @Throws(IllegalStateException::class, IOException::class)
-    fun refreshTokenWithHttpInfo(): ApiResponse<Unit?> {
+    fun refreshTokenWithHttpInfo(): ApiResponse<AuthenticationResponse?> {
         val localVariableConfig = refreshTokenRequestConfig()
 
-        return request<Unit, Unit>(
+        return request<Unit, AuthenticationResponse>(
             localVariableConfig,
         )
     }
@@ -890,10 +906,10 @@ class AccountControllerApi(
         ClientException::class,
         ServerException::class,
     )
-    fun register(registerRequest: RegisterRequest): AuthenticationResponse {
+    fun register(registerRequest: RegisterRequest): AuthenticationResponse = runBlocking(Dispatchers.IO) {
         val localVarResponse = registerWithHttpInfo(registerRequest = registerRequest)
 
-        return when (localVarResponse.responseType) {
+        return@runBlocking when (localVarResponse.responseType) {
             ResponseType.Success -> (localVarResponse as Success<*>).data as AuthenticationResponse
             ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
             ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
@@ -959,7 +975,7 @@ class AccountControllerApi(
     /**
      *
      *
-     * @param userId
+     * @param accountId
      * @return kotlin.Any
      * @throws IllegalStateException If the request is not correctly configured
      * @throws IOException Rethrows the OkHttp execute method exception
@@ -975,11 +991,97 @@ class AccountControllerApi(
         ClientException::class,
         ServerException::class,
     )
-    fun unbanUser(userId: kotlin.Long): kotlin.Any {
-        val localVarResponse = unbanUserWithHttpInfo(userId = userId)
+    fun removeAdmin(accountId: kotlin.Long, token: String) = runBlocking(Dispatchers.IO) {
+        val localVarResponse = removeAdminWithHttpInfo(accountId = accountId, token = token)
 
-        return when (localVarResponse.responseType) {
-            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
+        return@runBlocking when (localVarResponse.responseType) {
+            ResponseType.Success -> (localVarResponse as Success<*>)
+            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
+            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
+            ResponseType.ClientError -> {
+                val localVarError = localVarResponse as ClientError<*>
+                throw ClientException(
+                    "Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}",
+                    localVarError.statusCode,
+                    localVarResponse,
+                )
+            }
+            ResponseType.ServerError -> {
+                val localVarError = localVarResponse as ServerError<*>
+                throw ServerException(
+                    "Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}",
+                    localVarError.statusCode,
+                    localVarResponse,
+                )
+            }
+        }
+    }
+
+    /**
+     *
+     *
+     * @param accountId
+     * @return ApiResponse<kotlin.Any?>
+     * @throws IllegalStateException If the request is not correctly configured
+     * @throws IOException Rethrows the OkHttp execute method exception
+     */
+    @Suppress("UNCHECKED_CAST")
+    @Throws(IllegalStateException::class, IOException::class)
+    fun removeAdminWithHttpInfo(accountId: kotlin.Long, token: String): ApiResponse<kotlin.Any?> {
+        val localVariableConfig = removeAdminRequestConfig(accountId = accountId, token = token)
+
+        return request<Unit, kotlin.Any>(
+            localVariableConfig,
+        )
+    }
+
+    /**
+     * To obtain the request config of the operation removeAdmin
+     *
+     * @param accountId
+     * @return RequestConfig
+     */
+    fun removeAdminRequestConfig(accountId: kotlin.Long, token: String): RequestConfig<Unit> {
+        val localVariableBody = null
+        val localVariableQuery: MultiValueMap = mutableMapOf()
+        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
+
+        localVariableHeaders["Authorization"] = "Bearer $token"
+
+        return RequestConfig(
+            method = RequestMethod.PATCH,
+            path = "/api/account/removeAdmin/{accountId}".replace("{" + "accountId" + "}", encodeURIComponent(accountId.toString())),
+            query = localVariableQuery,
+            headers = localVariableHeaders,
+            requiresAuthentication = true,
+            body = localVariableBody,
+        )
+    }
+
+    /**
+     *
+     *
+     * @param accountId
+     * @return kotlin.Any
+     * @throws IllegalStateException If the request is not correctly configured
+     * @throws IOException Rethrows the OkHttp execute method exception
+     * @throws UnsupportedOperationException If the API returns an informational or redirection response
+     * @throws ClientException If the API returns a client error response
+     * @throws ServerException If the API returns a server error response
+     */
+    @Suppress("UNCHECKED_CAST")
+    @Throws(
+        IllegalStateException::class,
+        IOException::class,
+        UnsupportedOperationException::class,
+        ClientException::class,
+        ServerException::class,
+    )
+    fun unbanAccount(accountId: kotlin.Long, token: String) = runBlocking(Dispatchers.IO) {
+        val localVarResponse = unbanAccountWithHttpInfo(accountId = accountId, token = token)
+
+        return@runBlocking when (localVarResponse.responseType) {
+            ResponseType.Success -> (localVarResponse as Success<*>)
             ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
             ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
             ResponseType.ClientError -> {
@@ -1004,15 +1106,15 @@ class AccountControllerApi(
     /**
      *
      *
-     * @param userId
+     * @param accountId
      * @return ApiResponse<kotlin.Any?>
      * @throws IllegalStateException If the request is not correctly configured
      * @throws IOException Rethrows the OkHttp execute method exception
      */
     @Suppress("UNCHECKED_CAST")
     @Throws(IllegalStateException::class, IOException::class)
-    fun unbanUserWithHttpInfo(userId: kotlin.Long): ApiResponse<kotlin.Any?> {
-        val localVariableConfig = unbanUserRequestConfig(userId = userId)
+    fun unbanAccountWithHttpInfo(accountId: kotlin.Long, token: String): ApiResponse<kotlin.Any?> {
+        val localVariableConfig = unbanAccountRequestConfig(accountId = accountId, token = token)
 
         return request<Unit, kotlin.Any>(
             localVariableConfig,
@@ -1020,19 +1122,21 @@ class AccountControllerApi(
     }
 
     /**
-     * To obtain the request config of the operation unbanUser
+     * To obtain the request config of the operation unbanAccount
      *
-     * @param userId
+     * @param accountId
      * @return RequestConfig
      */
-    fun unbanUserRequestConfig(userId: kotlin.Long): RequestConfig<Unit> {
+    fun unbanAccountRequestConfig(accountId: kotlin.Long, token: String): RequestConfig<Unit> {
         val localVariableBody = null
         val localVariableQuery: MultiValueMap = mutableMapOf()
         val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
 
+        localVariableHeaders["Authorization"] = "Bearer $token"
+
         return RequestConfig(
             method = RequestMethod.PATCH,
-            path = "/api/account/unban/{userId}".replace("{" + "userId" + "}", encodeURIComponent(userId.toString())),
+            path = "/api/account/unban/{accountId}".replace("{" + "accountId" + "}", encodeURIComponent(accountId.toString())),
             query = localVariableQuery,
             headers = localVariableHeaders,
             requiresAuthentication = true,
@@ -1059,10 +1163,10 @@ class AccountControllerApi(
         ClientException::class,
         ServerException::class,
     )
-    fun updateUser(accountDto: AccountDto): kotlin.Any {
-        val localVarResponse = updateUserWithHttpInfo(accountDto = accountDto)
+    fun updateAccount(accountDto: AccountDto, token: String): kotlin.Any = runBlocking(Dispatchers.IO) {
+        val localVarResponse = updateAccountWithHttpInfo(accountDto = accountDto, token = token)
 
-        return when (localVarResponse.responseType) {
+        return@runBlocking when (localVarResponse.responseType) {
             ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
             ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
             ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
@@ -1095,8 +1199,8 @@ class AccountControllerApi(
      */
     @Suppress("UNCHECKED_CAST")
     @Throws(IllegalStateException::class, IOException::class)
-    fun updateUserWithHttpInfo(accountDto: AccountDto): ApiResponse<kotlin.Any?> {
-        val localVariableConfig = updateUserRequestConfig(accountDto = accountDto)
+    fun updateAccountWithHttpInfo(accountDto: AccountDto, token: String): ApiResponse<kotlin.Any?> {
+        val localVariableConfig = updateAccountRequestConfig(accountDto = accountDto, token = token)
 
         return request<AccountDto, kotlin.Any>(
             localVariableConfig,
@@ -1104,17 +1208,19 @@ class AccountControllerApi(
     }
 
     /**
-     * To obtain the request config of the operation updateUser
+     * To obtain the request config of the operation updateAccount
      *
      * @param accountDto
      * @return RequestConfig
      */
-    fun updateUserRequestConfig(accountDto: AccountDto): RequestConfig<AccountDto> {
+    fun updateAccountRequestConfig(accountDto: AccountDto, token: String): RequestConfig<AccountDto> {
         val localVariableBody = accountDto
         val localVariableQuery: MultiValueMap = mutableMapOf()
         val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
         localVariableHeaders["Content-Type"] = "application/json"
 
+        localVariableHeaders["Authorization"] = "Bearer $token"
+
         return RequestConfig(
             method = RequestMethod.PUT,
             path = "/api/account",
@@ -1125,6 +1231,112 @@ class AccountControllerApi(
         )
     }
 
+    /**
+     *
+     *
+     * @param accountShortDto
+     * @return kotlin.String
+     * @throws IllegalStateException If the request is not correctly configured
+     * @throws IOException Rethrows the OkHttp execute method exception
+     * @throws UnsupportedOperationException If the API returns an informational or redirection response
+     * @throws ClientException If the API returns a client error response
+     * @throws ServerException If the API returns a server error response
+     */
+    @Suppress("UNCHECKED_CAST")
+    @Throws(
+        IllegalStateException::class,
+        IOException::class,
+        UnsupportedOperationException::class,
+        ClientException::class,
+        ServerException::class,
+    )
+    fun updateImage(accountShortDto: AccountShortDto, token: String) = runBlocking(Dispatchers.IO) {
+        val localVarResponse = updateImageWithHttpInfo(accountShortDto = accountShortDto, token = token)
+
+        return@runBlocking when (localVarResponse.responseType) {
+            ResponseType.Success -> (localVarResponse as Success<*>)
+            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
+            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
+            ResponseType.ClientError -> {
+                val localVarError = localVarResponse as ClientError<*>
+                throw ClientException(
+                    "Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}",
+                    localVarError.statusCode,
+                    localVarResponse,
+                )
+            }
+            ResponseType.ServerError -> {
+                val localVarError = localVarResponse as ServerError<*>
+                throw ServerException(
+                    "Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}",
+                    localVarError.statusCode,
+                    localVarResponse,
+                )
+            }
+        }
+    }
+
+    /**
+     *
+     *
+     * @param accountShortDto
+     * @return ApiResponse<kotlin.String?>
+     * @throws IllegalStateException If the request is not correctly configured
+     * @throws IOException Rethrows the OkHttp execute method exception
+     */
+    @Suppress("UNCHECKED_CAST")
+    @Throws(IllegalStateException::class, IOException::class)
+    fun updateImageWithHttpInfo(accountShortDto: AccountShortDto, token: String): ApiResponse<kotlin.String?> {
+        val localVariableConfig = updateImageRequestConfig(accountShortDto = accountShortDto, token = token)
+
+        return request<AccountShortDto, kotlin.String>(
+            localVariableConfig,
+        )
+    }
+
+    /**
+     * To obtain the request config of the operation updateImage
+     *
+     * @param accountShortDto
+     * @return RequestConfig
+     */
+    fun updateImageRequestConfig(accountShortDto: AccountShortDto, token: String): RequestConfig<AccountShortDto> {
+        val localVariableBody = accountShortDto
+        val localVariableQuery: MultiValueMap = mutableMapOf()
+        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
+        localVariableHeaders["Content-Type"] = "application/json"
+
+        localVariableHeaders["Authorization"] = "Bearer $token"
+
+        return RequestConfig(
+            method = RequestMethod.PATCH,
+            path = "/api/account/update-image",
+            query = localVariableQuery,
+            headers = localVariableHeaders,
+            requiresAuthentication = true,
+            body = localVariableBody,
+        )
+    }
+
+    /**
+     *
+     *
+     * @return kotlin.String
+     * @throws IllegalStateException If the request is not correctly configured
+     * @throws IOException Rethrows the OkHttp execute method exception
+     * @throws UnsupportedOperationException If the API returns an informational or redirection response
+     * @throws ClientException If the API returns a client error response
+     * @throws ServerException If the API returns a server error response
+     */
+    @Suppress("UNCHECKED_CAST")
+    @Throws(
+        IllegalStateException::class,
+        IOException::class,
+        UnsupportedOperationException::class,
+        ClientException::class,
+        ServerException::class,
+    )
+
     private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
         HttpUrl
             .Builder()
diff --git a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/apis/CartControllerApi.kt b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/apis/CartControllerApi.kt
index fc97102..46d7e37 100644
--- a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/apis/CartControllerApi.kt
+++ b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/apis/CartControllerApi.kt
@@ -13,22 +13,25 @@
     "UnusedImport",
 )
 
-package org.openapitools.client.apis
+package it.unical.informatica.ea.sefora_frontend.apis
 
+import it.unical.informatica.ea.sefora_frontend.BuildConfig
+import kotlinx.coroutines.Dispatchers
+import kotlinx.coroutines.withContext
 import okhttp3.HttpUrl
 import okhttp3.OkHttpClient
-import org.openapitools.client.infrastructure.ApiClient
-import org.openapitools.client.infrastructure.ApiResponse
-import org.openapitools.client.infrastructure.ClientError
-import org.openapitools.client.infrastructure.ClientException
-import org.openapitools.client.infrastructure.MultiValueMap
-import org.openapitools.client.infrastructure.RequestConfig
-import org.openapitools.client.infrastructure.RequestMethod
-import org.openapitools.client.infrastructure.ResponseType
-import org.openapitools.client.infrastructure.ServerError
-import org.openapitools.client.infrastructure.ServerException
-import org.openapitools.client.infrastructure.Success
-import org.openapitools.client.models.CartDto
+import it.unical.informatica.ea.sefora_frontend.infrastructure.ApiClient
+import it.unical.informatica.ea.sefora_frontend.infrastructure.ApiResponse
+import it.unical.informatica.ea.sefora_frontend.infrastructure.ClientError
+import it.unical.informatica.ea.sefora_frontend.infrastructure.ClientException
+import it.unical.informatica.ea.sefora_frontend.infrastructure.MultiValueMap
+import it.unical.informatica.ea.sefora_frontend.infrastructure.RequestConfig
+import it.unical.informatica.ea.sefora_frontend.infrastructure.RequestMethod
+import it.unical.informatica.ea.sefora_frontend.infrastructure.ResponseType
+import it.unical.informatica.ea.sefora_frontend.infrastructure.ServerError
+import it.unical.informatica.ea.sefora_frontend.infrastructure.ServerException
+import it.unical.informatica.ea.sefora_frontend.infrastructure.Success
+import it.unical.informatica.ea.sefora_frontend.models.CartDto
 import java.io.IOException
 
 class CartControllerApi(
@@ -38,7 +41,7 @@ class CartControllerApi(
     companion object {
         @JvmStatic
         val defaultBasePath: String by lazy {
-            System.getProperties().getProperty(ApiClient.baseUrlKey, "http://localhost:8080")
+            System.getProperties().getProperty(ApiClient.baseUrlKey, BuildConfig.SERVER_ADDRESS)
         }
     }
 
@@ -62,13 +65,13 @@ class CartControllerApi(
         ClientException::class,
         ServerException::class,
     )
-    fun addProductToCart(
+    suspend fun addProductToCart(
         cartId: kotlin.Long,
         productId: kotlin.Long,
-    ): kotlin.String {
+    ): kotlin.String = withContext(Dispatchers.IO){
         val localVarResponse = addProductToCartWithHttpInfo(cartId = cartId, productId = productId)
 
-        return when (localVarResponse.responseType) {
+        return@withContext when (localVarResponse.responseType) {
             ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.String
             ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
             ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
@@ -162,10 +165,10 @@ class CartControllerApi(
         ClientException::class,
         ServerException::class,
     )
-    fun checkoutCart(cartId: kotlin.Long): kotlin.String {
+    suspend fun checkoutCart(cartId: kotlin.Long): kotlin.String = withContext(Dispatchers.IO){
         val localVarResponse = checkoutCartWithHttpInfo(cartId = cartId)
 
-        return when (localVarResponse.responseType) {
+        return@withContext when (localVarResponse.responseType) {
             ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.String
             ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
             ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
@@ -250,10 +253,10 @@ class CartControllerApi(
         ClientException::class,
         ServerException::class,
     )
-    fun createCart(cartDto: CartDto): CartDto {
+    suspend fun createCart(cartDto: CartDto): CartDto = withContext(Dispatchers.IO){
         val localVarResponse = createCartWithHttpInfo(cartDto = cartDto)
 
-        return when (localVarResponse.responseType) {
+        return@withContext when (localVarResponse.responseType) {
             ResponseType.Success -> (localVarResponse as Success<*>).data as CartDto
             ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
             ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
@@ -335,10 +338,10 @@ class CartControllerApi(
         ClientException::class,
         ServerException::class,
     )
-    fun getCartById(id: kotlin.Long): CartDto {
+    suspend fun getCartById(id: kotlin.Long): CartDto = withContext(Dispatchers.IO){
         val localVarResponse = getCartByIdWithHttpInfo(id = id)
 
-        return when (localVarResponse.responseType) {
+        return@withContext when (localVarResponse.responseType) {
             ResponseType.Success -> (localVarResponse as Success<*>).data as CartDto
             ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
             ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
@@ -418,10 +421,10 @@ class CartControllerApi(
         ClientException::class,
         ServerException::class,
     )
-    fun getCurrentUserCart(): CartDto {
+    suspend fun getCurrentUserCart(): CartDto = withContext(Dispatchers.IO){
         val localVarResponse = getCurrentUserCartWithHttpInfo()
 
-        return when (localVarResponse.responseType) {
+        return@withContext when (localVarResponse.responseType) {
             ResponseType.Success -> (localVarResponse as Success<*>).data as CartDto
             ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
             ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
@@ -501,13 +504,13 @@ class CartControllerApi(
         ClientException::class,
         ServerException::class,
     )
-    fun removeProductFromCart(
+    suspend fun removeProductFromCart(
         cartId: kotlin.Long,
         productId: kotlin.Long,
-    ): kotlin.String {
+    ): kotlin.String = withContext(Dispatchers.IO){
         val localVarResponse = removeProductFromCartWithHttpInfo(cartId = cartId, productId = productId)
 
-        return when (localVarResponse.responseType) {
+        return@withContext when (localVarResponse.responseType) {
             ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.String
             ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
             ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
@@ -601,10 +604,10 @@ class CartControllerApi(
         ClientException::class,
         ServerException::class,
     )
-    fun updateCart(cartDto: CartDto): kotlin.String {
+    suspend fun updateCart(cartDto: CartDto): kotlin.String = withContext(Dispatchers.IO){
         val localVarResponse = updateCartWithHttpInfo(cartDto = cartDto)
 
-        return when (localVarResponse.responseType) {
+        return@withContext when (localVarResponse.responseType) {
             ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.String
             ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
             ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
diff --git a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/apis/CartProductControllerApi.kt b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/apis/CartProductControllerApi.kt
deleted file mode 100644
index 3cf6766..0000000
--- a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/apis/CartProductControllerApi.kt
+++ /dev/null
@@ -1,328 +0,0 @@
-/**
- *
- * Please note:
- * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
- * Do not edit this file manually.
- *
- */
-
-@file:Suppress(
-    "ArrayInDataClass",
-    "EnumEntryName",
-    "RemoveRedundantQualifierName",
-    "UnusedImport", "unused"
-)
-
-package it.unical.informatica.ea.sefora_frontend.apis
-
-import java.io.IOException
-import okhttp3.OkHttpClient
-import okhttp3.HttpUrl
-
-import it.unical.informatica.ea.sefora_frontend.models.CartProductDto
-import it.unical.informatica.ea.sefora_frontend.BuildConfig
-import it.unical.informatica.ea.sefora_frontend.infrastructure.ApiClient
-import it.unical.informatica.ea.sefora_frontend.infrastructure.ApiResponse
-import it.unical.informatica.ea.sefora_frontend.infrastructure.ClientException
-import it.unical.informatica.ea.sefora_frontend.infrastructure.ClientError
-import it.unical.informatica.ea.sefora_frontend.infrastructure.ServerException
-import it.unical.informatica.ea.sefora_frontend.infrastructure.ServerError
-import it.unical.informatica.ea.sefora_frontend.infrastructure.MultiValueMap
-import it.unical.informatica.ea.sefora_frontend.infrastructure.RequestConfig
-import it.unical.informatica.ea.sefora_frontend.infrastructure.RequestMethod
-import it.unical.informatica.ea.sefora_frontend.infrastructure.ResponseType
-import it.unical.informatica.ea.sefora_frontend.infrastructure.Success
-import kotlinx.coroutines.Dispatchers
-import kotlinx.coroutines.withContext
-
-class CartProductControllerApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
-    companion object {
-        @JvmStatic
-        val defaultBasePath: String by lazy {
-            System.getProperties().getProperty(ApiClient.baseUrlKey, BuildConfig.SERVER_ADDRESS)
-        }
-    }
-
-    /**
-     * 
-     * 
-     * @param cartProductDto 
-     * @return CartProductDto
-     * @throws IllegalStateException If the request is not correctly configured
-     * @throws IOException Rethrows the OkHttp execute method exception
-     * @throws UnsupportedOperationException If the API returns an informational or redirection response
-     * @throws ClientException If the API returns a client error response
-     * @throws ServerException If the API returns a server error response
-     */
-    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
-    suspend fun createCartProduct(cartProductDto: CartProductDto) : CartProductDto = withContext(Dispatchers.IO) {
-        val localVarResponse = createCartProductWithHttpInfo(cartProductDto = cartProductDto)
-
-        return@withContext when (localVarResponse.responseType) {
-            ResponseType.Success -> (localVarResponse as Success<*>).data as CartProductDto
-            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
-            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
-            ResponseType.ClientError -> {
-                val localVarError = localVarResponse as ClientError<*>
-                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
-            }
-
-            ResponseType.ServerError -> {
-                val localVarError = localVarResponse as ServerError<*>
-                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
-            }
-        }
-    }
-
-    /**
-     * 
-     * 
-     * @param cartProductDto 
-     * @return ApiResponse<CartProductDto?>
-     * @throws IllegalStateException If the request is not correctly configured
-     * @throws IOException Rethrows the OkHttp execute method exception
-     */
-    @Throws(IllegalStateException::class, IOException::class)
-    fun createCartProductWithHttpInfo(cartProductDto: CartProductDto) : ApiResponse<CartProductDto?> {
-        val localVariableConfig = createCartProductRequestConfig(cartProductDto = cartProductDto)
-
-        return request<CartProductDto, CartProductDto>(
-            localVariableConfig
-        )
-    }
-
-    /**
-     * To obtain the request config of the operation createCartProduct
-     *
-     * @param cartProductDto 
-     * @return RequestConfig
-     */
-    fun createCartProductRequestConfig(cartProductDto: CartProductDto) : RequestConfig<CartProductDto> {
-        val localVariableBody = cartProductDto
-        val localVariableQuery: MultiValueMap = mutableMapOf()
-        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
-        localVariableHeaders["Content-Type"] = "application/json"
-        
-        return RequestConfig(
-            method = RequestMethod.POST,
-            path = "/api/cartproduct",
-            query = localVariableQuery,
-            headers = localVariableHeaders,
-            requiresAuthentication = true,
-            body = localVariableBody
-        )
-    }
-
-    /**
-     * 
-     * 
-     * @param id 
-     * @return kotlin.String
-     * @throws IllegalStateException If the request is not correctly configured
-     * @throws IOException Rethrows the OkHttp execute method exception
-     * @throws UnsupportedOperationException If the API returns an informational or redirection response
-     * @throws ClientException If the API returns a client error response
-     * @throws ServerException If the API returns a server error response
-     */
-    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
-    suspend fun deleteCartProduct(id: kotlin.Long) : kotlin.String = withContext(Dispatchers.IO) {
-        val localVarResponse = deleteCartProductWithHttpInfo(id = id)
-
-        return@withContext when (localVarResponse.responseType) {
-            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.String
-            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
-            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
-            ResponseType.ClientError -> {
-                val localVarError = localVarResponse as ClientError<*>
-                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
-            }
-
-            ResponseType.ServerError -> {
-                val localVarError = localVarResponse as ServerError<*>
-                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
-            }
-        }
-    }
-
-    /**
-     * 
-     * 
-     * @param id 
-     * @return ApiResponse<kotlin.String?>
-     * @throws IllegalStateException If the request is not correctly configured
-     * @throws IOException Rethrows the OkHttp execute method exception
-     */
-    @Throws(IllegalStateException::class, IOException::class)
-    fun deleteCartProductWithHttpInfo(id: kotlin.Long) : ApiResponse<kotlin.String?> {
-        val localVariableConfig = deleteCartProductRequestConfig(id = id)
-
-        return request<Unit, kotlin.String>(
-            localVariableConfig
-        )
-    }
-
-    /**
-     * To obtain the request config of the operation deleteCartProduct
-     *
-     * @param id 
-     * @return RequestConfig
-     */
-    fun deleteCartProductRequestConfig(id: kotlin.Long) : RequestConfig<Unit> {
-        val localVariableBody = null
-        val localVariableQuery: MultiValueMap = mutableMapOf()
-        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
-        
-        return RequestConfig(
-            method = RequestMethod.DELETE,
-            path = "/api/cartproduct/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
-            query = localVariableQuery,
-            headers = localVariableHeaders,
-            requiresAuthentication = true,
-            body = localVariableBody
-        )
-    }
-
-    /**
-     * 
-     * 
-     * @param id 
-     * @return kotlin.collections.List<CartProductDto>
-     * @throws IllegalStateException If the request is not correctly configured
-     * @throws IOException Rethrows the OkHttp execute method exception
-     * @throws UnsupportedOperationException If the API returns an informational or redirection response
-     * @throws ClientException If the API returns a client error response
-     * @throws ServerException If the API returns a server error response
-     */
-    @Suppress("UNCHECKED_CAST")
-    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
-    suspend fun getAllCartProductByCartId(id: kotlin.Long) : kotlin.collections.List<CartProductDto> = withContext(Dispatchers.IO) {
-        val localVarResponse = getAllCartProductByCartIdWithHttpInfo(id = id)
-
-        return@withContext when (localVarResponse.responseType) {
-            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<CartProductDto>
-            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
-            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
-            ResponseType.ClientError -> {
-                val localVarError = localVarResponse as ClientError<*>
-                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
-            }
-
-            ResponseType.ServerError -> {
-                val localVarError = localVarResponse as ServerError<*>
-                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
-            }
-        }
-    }
-
-    /**
-     * 
-     * 
-     * @param id 
-     * @return ApiResponse<kotlin.collections.List<CartProductDto>?>
-     * @throws IllegalStateException If the request is not correctly configured
-     * @throws IOException Rethrows the OkHttp execute method exception
-     */
-    @Throws(IllegalStateException::class, IOException::class)
-    fun getAllCartProductByCartIdWithHttpInfo(id: kotlin.Long) : ApiResponse<kotlin.collections.List<CartProductDto>?> {
-        val localVariableConfig = getAllCartProductByCartIdRequestConfig(id = id)
-
-        return request<Unit, kotlin.collections.List<CartProductDto>>(
-            localVariableConfig
-        )
-    }
-
-    /**
-     * To obtain the request config of the operation getAllCartProductByCartId
-     *
-     * @param id 
-     * @return RequestConfig
-     */
-    fun getAllCartProductByCartIdRequestConfig(id: kotlin.Long) : RequestConfig<Unit> {
-        val localVariableBody = null
-        val localVariableQuery: MultiValueMap = mutableMapOf()
-        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
-        
-        return RequestConfig(
-            method = RequestMethod.GET,
-            path = "/api/cartproduct/cart/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
-            query = localVariableQuery,
-            headers = localVariableHeaders,
-            requiresAuthentication = true,
-            body = localVariableBody
-        )
-    }
-
-    /**
-     * 
-     * 
-     * @param cartProductDto 
-     * @return kotlin.String
-     * @throws IllegalStateException If the request is not correctly configured
-     * @throws IOException Rethrows the OkHttp execute method exception
-     * @throws UnsupportedOperationException If the API returns an informational or redirection response
-     * @throws ClientException If the API returns a client error response
-     * @throws ServerException If the API returns a server error response
-     */
-    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
-    suspend fun updateCartProduct(cartProductDto: CartProductDto) : kotlin.String = withContext(Dispatchers.IO){
-        val localVarResponse = updateCartProductWithHttpInfo(cartProductDto = cartProductDto)
-
-        return@withContext when (localVarResponse.responseType) {
-            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.String
-            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
-            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
-            ResponseType.ClientError -> {
-                val localVarError = localVarResponse as ClientError<*>
-                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
-            }
-
-            ResponseType.ServerError -> {
-                val localVarError = localVarResponse as ServerError<*>
-                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
-            }
-        }
-    }
-
-    /**
-     * 
-     * 
-     * @param cartProductDto 
-     * @return ApiResponse<kotlin.String?>
-     * @throws IllegalStateException If the request is not correctly configured
-     * @throws IOException Rethrows the OkHttp execute method exception
-     */
-    @Throws(IllegalStateException::class, IOException::class)
-    fun updateCartProductWithHttpInfo(cartProductDto: CartProductDto) : ApiResponse<kotlin.String?> {
-        val localVariableConfig = updateCartProductRequestConfig(cartProductDto = cartProductDto)
-
-        return request<CartProductDto, kotlin.String>(
-            localVariableConfig
-        )
-    }
-
-    /**
-     * To obtain the request config of the operation updateCartProduct
-     *
-     * @param cartProductDto 
-     * @return RequestConfig
-     */
-    fun updateCartProductRequestConfig(cartProductDto: CartProductDto) : RequestConfig<CartProductDto> {
-        val localVariableBody = cartProductDto
-        val localVariableQuery: MultiValueMap = mutableMapOf()
-        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
-        localVariableHeaders["Content-Type"] = "application/json"
-        
-        return RequestConfig(
-            method = RequestMethod.PUT,
-            path = "/api/cartproduct",
-            query = localVariableQuery,
-            headers = localVariableHeaders,
-            requiresAuthentication = true,
-            body = localVariableBody
-        )
-    }
-
-
-    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
-        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
-}
diff --git a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/apis/OrderControllerApi.kt b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/apis/OrderControllerApi.kt
deleted file mode 100644
index 9a28e22..0000000
--- a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/apis/OrderControllerApi.kt
+++ /dev/null
@@ -1,189 +0,0 @@
-/**
- *
- * Please note:
- * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
- * Do not edit this file manually.
- *
- */
-
-@file:Suppress(
-    "ArrayInDataClass",
-    "EnumEntryName",
-    "RemoveRedundantQualifierName",
-    "UnusedImport", "unused"
-)
-
-package it.unical.informatica.ea.sefora_frontend.apis
-
-import java.io.IOException
-import okhttp3.OkHttpClient
-import okhttp3.HttpUrl
-
-import it.unical.informatica.ea.sefora_frontend.models.OrderDto
-import it.unical.informatica.ea.sefora_frontend.BuildConfig
-import it.unical.informatica.ea.sefora_frontend.infrastructure.ApiClient
-import it.unical.informatica.ea.sefora_frontend.infrastructure.ApiResponse
-import it.unical.informatica.ea.sefora_frontend.infrastructure.ClientException
-import it.unical.informatica.ea.sefora_frontend.infrastructure.ClientError
-import it.unical.informatica.ea.sefora_frontend.infrastructure.ServerException
-import it.unical.informatica.ea.sefora_frontend.infrastructure.ServerError
-import it.unical.informatica.ea.sefora_frontend.infrastructure.MultiValueMap
-import it.unical.informatica.ea.sefora_frontend.infrastructure.RequestConfig
-import it.unical.informatica.ea.sefora_frontend.infrastructure.RequestMethod
-import it.unical.informatica.ea.sefora_frontend.infrastructure.ResponseType
-import it.unical.informatica.ea.sefora_frontend.infrastructure.Success
-import kotlinx.coroutines.Dispatchers
-import kotlinx.coroutines.withContext
-
-class OrderControllerApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
-    companion object {
-        @JvmStatic
-        val defaultBasePath: String by lazy {
-            System.getProperties().getProperty(ApiClient.baseUrlKey, BuildConfig.SERVER_ADDRESS)
-        }
-    }
-
-    /**
-     * 
-     * 
-     * @param orderDto 
-     * @return OrderDto
-     * @throws IllegalStateException If the request is not correctly configured
-     * @throws IOException Rethrows the OkHttp execute method exception
-     * @throws UnsupportedOperationException If the API returns an informational or redirection response
-     * @throws ClientException If the API returns a client error response
-     * @throws ServerException If the API returns a server error response
-     */
-    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
-    suspend fun createOrder(orderDto: OrderDto) : OrderDto = withContext(Dispatchers.IO){
-        val localVarResponse = createOrderWithHttpInfo(orderDto = orderDto)
-
-        return@withContext when (localVarResponse.responseType) {
-            ResponseType.Success -> (localVarResponse as Success<*>).data as OrderDto
-            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
-            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
-            ResponseType.ClientError -> {
-                val localVarError = localVarResponse as ClientError<*>
-                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
-            }
-
-            ResponseType.ServerError -> {
-                val localVarError = localVarResponse as ServerError<*>
-                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
-            }
-        }
-    }
-
-    /**
-     * 
-     * 
-     * @param orderDto 
-     * @return ApiResponse<OrderDto?>
-     * @throws IllegalStateException If the request is not correctly configured
-     * @throws IOException Rethrows the OkHttp execute method exception
-     */
-    @Throws(IllegalStateException::class, IOException::class)
-    fun createOrderWithHttpInfo(orderDto: OrderDto) : ApiResponse<OrderDto?> {
-        val localVariableConfig = createOrderRequestConfig(orderDto = orderDto)
-
-        return request<OrderDto, OrderDto>(
-            localVariableConfig
-        )
-    }
-
-    /**
-     * To obtain the request config of the operation createOrder
-     *
-     * @param orderDto 
-     * @return RequestConfig
-     */
-    fun createOrderRequestConfig(orderDto: OrderDto) : RequestConfig<OrderDto> {
-        val localVariableBody = orderDto
-        val localVariableQuery: MultiValueMap = mutableMapOf()
-        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
-        localVariableHeaders["Content-Type"] = "application/json"
-        
-        return RequestConfig(
-            method = RequestMethod.POST,
-            path = "/api/order",
-            query = localVariableQuery,
-            headers = localVariableHeaders,
-            requiresAuthentication = true,
-            body = localVariableBody
-        )
-    }
-
-    /**
-     * 
-     * 
-     * @param id 
-     * @return kotlin.collections.List<OrderDto>
-     * @throws IllegalStateException If the request is not correctly configured
-     * @throws IOException Rethrows the OkHttp execute method exception
-     * @throws UnsupportedOperationException If the API returns an informational or redirection response
-     * @throws ClientException If the API returns a client error response
-     * @throws ServerException If the API returns a server error response
-     */
-    @Suppress("UNCHECKED_CAST")
-    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
-    suspend fun findOrdersbyUserId(id: kotlin.Long) : kotlin.collections.List<OrderDto> = withContext(Dispatchers.IO){
-        val localVarResponse = findOrdersbyUserIdWithHttpInfo(id = id)
-
-        return@withContext when (localVarResponse.responseType) {
-            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<OrderDto>
-            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
-            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
-            ResponseType.ClientError -> {
-                val localVarError = localVarResponse as ClientError<*>
-                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
-            }
-
-            ResponseType.ServerError -> {
-                val localVarError = localVarResponse as ServerError<*>
-                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
-            }
-        }
-    }
-
-    /**
-     * 
-     * 
-     * @param id 
-     * @return ApiResponse<kotlin.collections.List<OrderDto>?>
-     * @throws IllegalStateException If the request is not correctly configured
-     * @throws IOException Rethrows the OkHttp execute method exception
-     */
-    @Throws(IllegalStateException::class, IOException::class)
-    fun findOrdersbyUserIdWithHttpInfo(id: kotlin.Long) : ApiResponse<kotlin.collections.List<OrderDto>?> {
-        val localVariableConfig = findOrdersbyUserIdRequestConfig(id = id)
-
-        return request<Unit, kotlin.collections.List<OrderDto>>(
-            localVariableConfig
-        )
-    }
-
-    /**
-     * To obtain the request config of the operation findOrdersbyUserId
-     *
-     * @param id 
-     * @return RequestConfig
-     */
-    fun findOrdersbyUserIdRequestConfig(id: kotlin.Long) : RequestConfig<Unit> {
-        val localVariableBody = null
-        val localVariableQuery: MultiValueMap = mutableMapOf()
-        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
-        
-        return RequestConfig(
-            method = RequestMethod.GET,
-            path = "/api/order/user/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
-            query = localVariableQuery,
-            headers = localVariableHeaders,
-            requiresAuthentication = true,
-            body = localVariableBody
-        )
-    }
-
-
-    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
-        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
-}
diff --git a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/apis/OrderProductControllerApi.kt b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/apis/OrderProductControllerApi.kt
deleted file mode 100644
index b79c549..0000000
--- a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/apis/OrderProductControllerApi.kt
+++ /dev/null
@@ -1,189 +0,0 @@
-/**
- *
- * Please note:
- * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
- * Do not edit this file manually.
- *
- */
-
-@file:Suppress(
-    "ArrayInDataClass",
-    "EnumEntryName",
-    "RemoveRedundantQualifierName",
-    "UnusedImport", "unused"
-)
-
-package it.unical.informatica.ea.sefora_frontend.apis
-
-import java.io.IOException
-import okhttp3.OkHttpClient
-import okhttp3.HttpUrl
-
-import it.unical.informatica.ea.sefora_frontend.models.OrderProductDto
-import it.unical.informatica.ea.sefora_frontend.BuildConfig
-import it.unical.informatica.ea.sefora_frontend.infrastructure.ApiClient
-import it.unical.informatica.ea.sefora_frontend.infrastructure.ApiResponse
-import it.unical.informatica.ea.sefora_frontend.infrastructure.ClientException
-import it.unical.informatica.ea.sefora_frontend.infrastructure.ClientError
-import it.unical.informatica.ea.sefora_frontend.infrastructure.ServerException
-import it.unical.informatica.ea.sefora_frontend.infrastructure.ServerError
-import it.unical.informatica.ea.sefora_frontend.infrastructure.MultiValueMap
-import it.unical.informatica.ea.sefora_frontend.infrastructure.RequestConfig
-import it.unical.informatica.ea.sefora_frontend.infrastructure.RequestMethod
-import it.unical.informatica.ea.sefora_frontend.infrastructure.ResponseType
-import it.unical.informatica.ea.sefora_frontend.infrastructure.Success
-import kotlinx.coroutines.Dispatchers
-import kotlinx.coroutines.withContext
-
-class OrderProductControllerApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
-    companion object {
-        @JvmStatic
-        val defaultBasePath: String by lazy {
-            System.getProperties().getProperty(ApiClient.baseUrlKey, BuildConfig.SERVER_ADDRESS)
-        }
-    }
-
-    /**
-     * 
-     * 
-     * @param orderProductDto 
-     * @return OrderProductDto
-     * @throws IllegalStateException If the request is not correctly configured
-     * @throws IOException Rethrows the OkHttp execute method exception
-     * @throws UnsupportedOperationException If the API returns an informational or redirection response
-     * @throws ClientException If the API returns a client error response
-     * @throws ServerException If the API returns a server error response
-     */
-    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
-    suspend fun createOrderProduct(orderProductDto: OrderProductDto) : OrderProductDto = withContext(Dispatchers.IO){
-        val localVarResponse = createOrderProductWithHttpInfo(orderProductDto = orderProductDto)
-
-        return@withContext when (localVarResponse.responseType) {
-            ResponseType.Success -> (localVarResponse as Success<*>).data as OrderProductDto
-            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
-            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
-            ResponseType.ClientError -> {
-                val localVarError = localVarResponse as ClientError<*>
-                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
-            }
-
-            ResponseType.ServerError -> {
-                val localVarError = localVarResponse as ServerError<*>
-                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
-            }
-        }
-    }
-
-    /**
-     * 
-     * 
-     * @param orderProductDto 
-     * @return ApiResponse<OrderProductDto?>
-     * @throws IllegalStateException If the request is not correctly configured
-     * @throws IOException Rethrows the OkHttp execute method exception
-     */
-    @Throws(IllegalStateException::class, IOException::class)
-    fun createOrderProductWithHttpInfo(orderProductDto: OrderProductDto) : ApiResponse<OrderProductDto?> {
-        val localVariableConfig = createOrderProductRequestConfig(orderProductDto = orderProductDto)
-
-        return request<OrderProductDto, OrderProductDto>(
-            localVariableConfig
-        )
-    }
-
-    /**
-     * To obtain the request config of the operation createOrderProduct
-     *
-     * @param orderProductDto 
-     * @return RequestConfig
-     */
-    fun createOrderProductRequestConfig(orderProductDto: OrderProductDto) : RequestConfig<OrderProductDto> {
-        val localVariableBody = orderProductDto
-        val localVariableQuery: MultiValueMap = mutableMapOf()
-        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
-        localVariableHeaders["Content-Type"] = "application/json"
-        
-        return RequestConfig(
-            method = RequestMethod.POST,
-            path = "/api/orderProduct",
-            query = localVariableQuery,
-            headers = localVariableHeaders,
-            requiresAuthentication = true,
-            body = localVariableBody
-        )
-    }
-
-    /**
-     * 
-     * 
-     * @param id 
-     * @return kotlin.collections.List<OrderProductDto>
-     * @throws IllegalStateException If the request is not correctly configured
-     * @throws IOException Rethrows the OkHttp execute method exception
-     * @throws UnsupportedOperationException If the API returns an informational or redirection response
-     * @throws ClientException If the API returns a client error response
-     * @throws ServerException If the API returns a server error response
-     */
-    @Suppress("UNCHECKED_CAST")
-    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
-    suspend fun getOrderProductsByOrderId(id: kotlin.Long) : kotlin.collections.List<OrderProductDto> = withContext(Dispatchers.IO) {
-        val localVarResponse = getOrderProductsByOrderIdWithHttpInfo(id = id)
-
-        return@withContext when (localVarResponse.responseType) {
-            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<OrderProductDto>
-            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
-            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
-            ResponseType.ClientError -> {
-                val localVarError = localVarResponse as ClientError<*>
-                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
-            }
-
-            ResponseType.ServerError -> {
-                val localVarError = localVarResponse as ServerError<*>
-                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
-            }
-        }
-    }
-
-    /**
-     * 
-     * 
-     * @param id 
-     * @return ApiResponse<kotlin.collections.List<OrderProductDto>?>
-     * @throws IllegalStateException If the request is not correctly configured
-     * @throws IOException Rethrows the OkHttp execute method exception
-     */
-    @Throws(IllegalStateException::class, IOException::class)
-    fun getOrderProductsByOrderIdWithHttpInfo(id: kotlin.Long) : ApiResponse<kotlin.collections.List<OrderProductDto>?> {
-        val localVariableConfig = getOrderProductsByOrderIdRequestConfig(id = id)
-
-        return request<Unit, kotlin.collections.List<OrderProductDto>>(
-            localVariableConfig
-        )
-    }
-
-    /**
-     * To obtain the request config of the operation getOrderProductsByOrderId
-     *
-     * @param id 
-     * @return RequestConfig
-     */
-    fun getOrderProductsByOrderIdRequestConfig(id: kotlin.Long) : RequestConfig<Unit> {
-        val localVariableBody = null
-        val localVariableQuery: MultiValueMap = mutableMapOf()
-        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
-        
-        return RequestConfig(
-            method = RequestMethod.GET,
-            path = "/api/orderProduct/order/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
-            query = localVariableQuery,
-            headers = localVariableHeaders,
-            requiresAuthentication = true,
-            body = localVariableBody
-        )
-    }
-
-
-    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
-        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
-}
diff --git a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/apis/ProductControllerApi.kt b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/apis/ProductControllerApi.kt
index 75e1272..98ba005 100644
--- a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/apis/ProductControllerApi.kt
+++ b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/apis/ProductControllerApi.kt
@@ -13,22 +13,25 @@
     "UnusedImport",
 )
 
-package org.openapitools.client.apis
+package it.unical.informatica.ea.sefora_frontend.apis
 
+import it.unical.informatica.ea.sefora_frontend.BuildConfig
+import kotlinx.coroutines.Dispatchers
+import kotlinx.coroutines.withContext
 import okhttp3.HttpUrl
 import okhttp3.OkHttpClient
-import org.openapitools.client.infrastructure.ApiClient
-import org.openapitools.client.infrastructure.ApiResponse
-import org.openapitools.client.infrastructure.ClientError
-import org.openapitools.client.infrastructure.ClientException
-import org.openapitools.client.infrastructure.MultiValueMap
-import org.openapitools.client.infrastructure.RequestConfig
-import org.openapitools.client.infrastructure.RequestMethod
-import org.openapitools.client.infrastructure.ResponseType
-import org.openapitools.client.infrastructure.ServerError
-import org.openapitools.client.infrastructure.ServerException
-import org.openapitools.client.infrastructure.Success
-import org.openapitools.client.models.ProductDto
+import it.unical.informatica.ea.sefora_frontend.infrastructure.ApiClient
+import it.unical.informatica.ea.sefora_frontend.infrastructure.ApiResponse
+import it.unical.informatica.ea.sefora_frontend.infrastructure.ClientError
+import it.unical.informatica.ea.sefora_frontend.infrastructure.ClientException
+import it.unical.informatica.ea.sefora_frontend.infrastructure.MultiValueMap
+import it.unical.informatica.ea.sefora_frontend.infrastructure.RequestConfig
+import it.unical.informatica.ea.sefora_frontend.infrastructure.RequestMethod
+import it.unical.informatica.ea.sefora_frontend.infrastructure.ResponseType
+import it.unical.informatica.ea.sefora_frontend.infrastructure.ServerError
+import it.unical.informatica.ea.sefora_frontend.infrastructure.ServerException
+import it.unical.informatica.ea.sefora_frontend.infrastructure.Success
+import it.unical.informatica.ea.sefora_frontend.models.ProductDto
 import java.io.IOException
 
 class ProductControllerApi(
@@ -38,7 +41,7 @@ class ProductControllerApi(
     companion object {
         @JvmStatic
         val defaultBasePath: String by lazy {
-            System.getProperties().getProperty(ApiClient.baseUrlKey, "http://localhost:8080")
+            System.getProperties().getProperty(ApiClient.baseUrlKey, BuildConfig.SERVER_ADDRESS)
         }
     }
 
@@ -61,10 +64,10 @@ class ProductControllerApi(
         ClientException::class,
         ServerException::class,
     )
-    fun createProduct(productDto: ProductDto): ProductDto {
-        val localVarResponse = createProductWithHttpInfo(productDto = productDto)
+    suspend fun createProduct(productDto: ProductDto, token: String): ProductDto = withContext(Dispatchers.IO){
+        val localVarResponse = createProductWithHttpInfo(productDto = productDto, token = token)
 
-        return when (localVarResponse.responseType) {
+        return@withContext when (localVarResponse.responseType) {
             ResponseType.Success -> (localVarResponse as Success<*>).data as ProductDto
             ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
             ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
@@ -97,8 +100,8 @@ class ProductControllerApi(
      */
     @Suppress("UNCHECKED_CAST")
     @Throws(IllegalStateException::class, IOException::class)
-    fun createProductWithHttpInfo(productDto: ProductDto): ApiResponse<ProductDto?> {
-        val localVariableConfig = createProductRequestConfig(productDto = productDto)
+    fun createProductWithHttpInfo(productDto: ProductDto, token: String): ApiResponse<ProductDto?> {
+        val localVariableConfig = createProductRequestConfig(productDto = productDto, token = token)
 
         return request<ProductDto, ProductDto>(
             localVariableConfig,
@@ -111,12 +114,14 @@ class ProductControllerApi(
      * @param productDto
      * @return RequestConfig
      */
-    fun createProductRequestConfig(productDto: ProductDto): RequestConfig<ProductDto> {
+    fun createProductRequestConfig(productDto: ProductDto, token: String): RequestConfig<ProductDto> {
         val localVariableBody = productDto
         val localVariableQuery: MultiValueMap = mutableMapOf()
         val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
         localVariableHeaders["Content-Type"] = "application/json"
 
+        localVariableHeaders["Authorization"] = "Bearer $token"
+
         return RequestConfig(
             method = RequestMethod.POST,
             path = "/api/product",
@@ -146,10 +151,10 @@ class ProductControllerApi(
         ClientException::class,
         ServerException::class,
     )
-    fun deleteProduct(id: kotlin.Long): kotlin.String {
+    suspend fun deleteProduct(id: kotlin.Long): kotlin.String = withContext(Dispatchers.IO){
         val localVarResponse = deleteProductWithHttpInfo(id = id)
 
-        return when (localVarResponse.responseType) {
+        return@withContext when (localVarResponse.responseType) {
             ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.String
             ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
             ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
@@ -229,10 +234,10 @@ class ProductControllerApi(
         ClientException::class,
         ServerException::class,
     )
-    fun findProductsByCurrentUser(): kotlin.collections.List<ProductDto> {
+    suspend fun findProductsByCurrentUser(): kotlin.collections.List<ProductDto> = withContext(Dispatchers.IO){
         val localVarResponse = findProductsByCurrentUserWithHttpInfo()
 
-        return when (localVarResponse.responseType) {
+        return@withContext when (localVarResponse.responseType) {
             ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<ProductDto>
             ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
             ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
@@ -310,10 +315,10 @@ class ProductControllerApi(
         ClientException::class,
         ServerException::class,
     )
-    fun getAllProducts(): kotlin.collections.List<ProductDto> {
+    suspend fun getAllProducts(): kotlin.collections.List<ProductDto> = withContext(Dispatchers.IO){
         val localVarResponse = getAllProductsWithHttpInfo()
 
-        return when (localVarResponse.responseType) {
+        return@withContext when (localVarResponse.responseType) {
             ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<ProductDto>
             ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
             ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
@@ -392,10 +397,10 @@ class ProductControllerApi(
         ClientException::class,
         ServerException::class,
     )
-    fun getAllProductsByOwner(id: kotlin.Long): kotlin.collections.List<ProductDto> {
+    suspend fun getAllProductsByOwner(id: kotlin.Long): kotlin.collections.List<ProductDto> = withContext(Dispatchers.IO) {
         val localVarResponse = getAllProductsByOwnerWithHttpInfo(id = id)
 
-        return when (localVarResponse.responseType) {
+        return@withContext when (localVarResponse.responseType) {
             ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<ProductDto>
             ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
             ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
@@ -476,10 +481,10 @@ class ProductControllerApi(
         ClientException::class,
         ServerException::class,
     )
-    fun getProductById(id: kotlin.Long): ProductDto {
+    suspend fun getProductById(id: kotlin.Long): ProductDto = withContext(Dispatchers.IO){
         val localVarResponse = getProductByIdWithHttpInfo(id = id)
 
-        return when (localVarResponse.responseType) {
+        return@withContext when (localVarResponse.responseType) {
             ResponseType.Success -> (localVarResponse as Success<*>).data as ProductDto
             ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
             ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
diff --git a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/apis/PurchaseControllerApi.kt b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/apis/PurchaseControllerApi.kt
index 0553412..51da670 100644
--- a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/apis/PurchaseControllerApi.kt
+++ b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/apis/PurchaseControllerApi.kt
@@ -13,22 +13,26 @@
     "UnusedImport",
 )
 
-package org.openapitools.client.apis
+package it.unical.informatica.ea.sefora_frontend.apis
 
+import it.unical.informatica.ea.sefora_frontend.BuildConfig
+import kotlinx.coroutines.Dispatchers
+import kotlinx.coroutines.withContext
 import okhttp3.HttpUrl
 import okhttp3.OkHttpClient
-import org.openapitools.client.infrastructure.ApiClient
-import org.openapitools.client.infrastructure.ApiResponse
-import org.openapitools.client.infrastructure.ClientError
-import org.openapitools.client.infrastructure.ClientException
-import org.openapitools.client.infrastructure.MultiValueMap
-import org.openapitools.client.infrastructure.RequestConfig
-import org.openapitools.client.infrastructure.RequestMethod
-import org.openapitools.client.infrastructure.ResponseType
-import org.openapitools.client.infrastructure.ServerError
-import org.openapitools.client.infrastructure.ServerException
-import org.openapitools.client.infrastructure.Success
-import org.openapitools.client.models.PurchaseDto
+import it.unical.informatica.ea.sefora_frontend.infrastructure.ApiClient
+import it.unical.informatica.ea.sefora_frontend.infrastructure.ApiResponse
+import it.unical.informatica.ea.sefora_frontend.infrastructure.ClientError
+import it.unical.informatica.ea.sefora_frontend.infrastructure.ClientException
+import it.unical.informatica.ea.sefora_frontend.infrastructure.MultiValueMap
+import it.unical.informatica.ea.sefora_frontend.infrastructure.RequestConfig
+import it.unical.informatica.ea.sefora_frontend.infrastructure.RequestMethod
+import it.unical.informatica.ea.sefora_frontend.infrastructure.ResponseType
+import it.unical.informatica.ea.sefora_frontend.infrastructure.ServerError
+import it.unical.informatica.ea.sefora_frontend.infrastructure.ServerException
+import it.unical.informatica.ea.sefora_frontend.infrastructure.Success
+import it.unical.informatica.ea.sefora_frontend.models.PurchaseDto
+import kotlinx.coroutines.runBlocking
 import java.io.IOException
 
 class PurchaseControllerApi(
@@ -38,10 +42,82 @@ class PurchaseControllerApi(
     companion object {
         @JvmStatic
         val defaultBasePath: String by lazy {
-            System.getProperties().getProperty(ApiClient.baseUrlKey, "http://localhost:8080")
+            System.getProperties().getProperty(ApiClient.baseUrlKey, BuildConfig.SERVER_ADDRESS)
         }
     }
 
+    /**
+     *
+     *
+     * @param id
+     * @return PurchaseDto
+     * @throws IllegalStateException If the request is not correctly configured
+     * @throws IOException Rethrows the OkHttp execute method exception
+     * @throws UnsupportedOperationException If the API returns an informational or redirection response
+     * @throws ClientException If the API returns a client error response
+     * @throws ServerException If the API returns a server error response
+     */
+    @Suppress("UNCHECKED_CAST")
+    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
+    fun convertProductToPurchase(id: kotlin.Long, token: String) : PurchaseDto = runBlocking(Dispatchers.IO) {
+        val localVarResponse = convertProductToPurchaseWithHttpInfo(id = id, token = token)
+
+        return@runBlocking when (localVarResponse.responseType) {
+            ResponseType.Success -> (localVarResponse as Success<*>).data as PurchaseDto
+            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
+            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
+            ResponseType.ClientError -> {
+                val localVarError = localVarResponse as ClientError<*>
+                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
+            }
+            ResponseType.ServerError -> {
+                val localVarError = localVarResponse as ServerError<*>
+                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
+            }
+        }
+    }
+
+    /**
+     *
+     *
+     * @param id
+     * @return ApiResponse<PurchaseDto?>
+     * @throws IllegalStateException If the request is not correctly configured
+     * @throws IOException Rethrows the OkHttp execute method exception
+     */
+    @Suppress("UNCHECKED_CAST")
+    @Throws(IllegalStateException::class, IOException::class)
+    fun convertProductToPurchaseWithHttpInfo(id: kotlin.Long, token: String) : ApiResponse<PurchaseDto?> {
+        val localVariableConfig = convertProductToPurchaseRequestConfig(id = id, token = token)
+
+        return request<Unit, PurchaseDto>(
+            localVariableConfig
+        )
+    }
+
+    /**
+     * To obtain the request config of the operation convertProductToPurchase
+     *
+     * @param id
+     * @return RequestConfig
+     */
+    fun convertProductToPurchaseRequestConfig(id: kotlin.Long, token: String) : RequestConfig<Unit> {
+        val localVariableBody = null
+        val localVariableQuery: MultiValueMap = mutableMapOf()
+        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
+
+        localVariableHeaders["Authorization"] = "Bearer $token"
+
+        return RequestConfig(
+            method = RequestMethod.PATCH,
+            path = "/api/order/convert/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
+            query = localVariableQuery,
+            headers = localVariableHeaders,
+            requiresAuthentication = true,
+            body = localVariableBody
+        )
+    }
+
     /**
      *
      *
@@ -61,10 +137,10 @@ class PurchaseControllerApi(
         ClientException::class,
         ServerException::class,
     )
-    fun createOrder(purchaseDto: PurchaseDto): PurchaseDto {
+    suspend fun createOrder(purchaseDto: PurchaseDto): PurchaseDto = withContext(Dispatchers.IO){
         val localVarResponse = createOrderWithHttpInfo(purchaseDto = purchaseDto)
 
-        return when (localVarResponse.responseType) {
+        return@withContext when (localVarResponse.responseType) {
             ResponseType.Success -> (localVarResponse as Success<*>).data as PurchaseDto
             ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
             ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
@@ -145,10 +221,10 @@ class PurchaseControllerApi(
         ClientException::class,
         ServerException::class,
     )
-    fun findOrdersByCurrentUser(): kotlin.collections.List<PurchaseDto> {
-        val localVarResponse = findOrdersByCurrentUserWithHttpInfo()
+    suspend fun findOrdersByCurrentUser(token: String): kotlin.collections.List<PurchaseDto> = withContext(Dispatchers.IO){
+        val localVarResponse = findOrdersByCurrentUserWithHttpInfo(token = token)
 
-        return when (localVarResponse.responseType) {
+        return@withContext when (localVarResponse.responseType) {
             ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<PurchaseDto>
             ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
             ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
@@ -180,8 +256,8 @@ class PurchaseControllerApi(
      */
     @Suppress("UNCHECKED_CAST")
     @Throws(IllegalStateException::class, IOException::class)
-    fun findOrdersByCurrentUserWithHttpInfo(): ApiResponse<kotlin.collections.List<PurchaseDto>?> {
-        val localVariableConfig = findOrdersByCurrentUserRequestConfig()
+    fun findOrdersByCurrentUserWithHttpInfo(token: String): ApiResponse<kotlin.collections.List<PurchaseDto>?> {
+        val localVariableConfig = findOrdersByCurrentUserRequestConfig(token = token)
 
         return request<Unit, kotlin.collections.List<PurchaseDto>>(
             localVariableConfig,
@@ -193,11 +269,13 @@ class PurchaseControllerApi(
      *
      * @return RequestConfig
      */
-    fun findOrdersByCurrentUserRequestConfig(): RequestConfig<Unit> {
+    fun findOrdersByCurrentUserRequestConfig(token: String): RequestConfig<Unit> {
         val localVariableBody = null
         val localVariableQuery: MultiValueMap = mutableMapOf()
         val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
 
+        localVariableHeaders["Authorization"] = "Bearer $token"
+
         return RequestConfig(
             method = RequestMethod.GET,
             path = "/api/order/current",
@@ -227,10 +305,10 @@ class PurchaseControllerApi(
         ClientException::class,
         ServerException::class,
     )
-    fun findOrdersByUserId(id: kotlin.Long): kotlin.collections.List<PurchaseDto> {
+    suspend fun findOrdersByUserId(id: kotlin.Long): kotlin.collections.List<PurchaseDto> = withContext(Dispatchers.IO){
         val localVarResponse = findOrdersByUserIdWithHttpInfo(id = id)
 
-        return when (localVarResponse.responseType) {
+        return@withContext when (localVarResponse.responseType) {
             ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<PurchaseDto>
             ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
             ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
diff --git a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/apis/UserControllerApi.kt b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/apis/UserControllerApi.kt
deleted file mode 100644
index 66ff6e4..0000000
--- a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/apis/UserControllerApi.kt
+++ /dev/null
@@ -1,324 +0,0 @@
-/**
- *
- * Please note:
- * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
- * Do not edit this file manually.
- *
- */
-
-@file:Suppress(
-    "ArrayInDataClass",
-    "EnumEntryName",
-    "RemoveRedundantQualifierName",
-    "UnusedImport", "unused"
-)
-
-package it.unical.informatica.ea.sefora_frontend.apis
-
-import it.unical.informatica.ea.sefora_frontend.BuildConfig
-import java.io.IOException
-import okhttp3.OkHttpClient
-import okhttp3.HttpUrl
-
-import it.unical.informatica.ea.sefora_frontend.models.AuthenticationRequest
-import it.unical.informatica.ea.sefora_frontend.models.AuthenticationResponse
-import it.unical.informatica.ea.sefora_frontend.models.ChangePasswordRequest
-import it.unical.informatica.ea.sefora_frontend.models.RegisterRequest
-
-import it.unical.informatica.ea.sefora_frontend.infrastructure.ApiClient
-import it.unical.informatica.ea.sefora_frontend.infrastructure.ApiResponse
-import it.unical.informatica.ea.sefora_frontend.infrastructure.ClientException
-import it.unical.informatica.ea.sefora_frontend.infrastructure.ClientError
-import it.unical.informatica.ea.sefora_frontend.infrastructure.ServerException
-import it.unical.informatica.ea.sefora_frontend.infrastructure.ServerError
-import it.unical.informatica.ea.sefora_frontend.infrastructure.MultiValueMap
-import it.unical.informatica.ea.sefora_frontend.infrastructure.RequestConfig
-import it.unical.informatica.ea.sefora_frontend.infrastructure.RequestMethod
-import it.unical.informatica.ea.sefora_frontend.infrastructure.ResponseType
-import it.unical.informatica.ea.sefora_frontend.infrastructure.Success
-import kotlinx.coroutines.Dispatchers
-import kotlinx.coroutines.withContext
-
-class UserControllerApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
-    companion object {
-        @JvmStatic
-        val defaultBasePath: String by lazy {
-            System.getProperties().getProperty(ApiClient.baseUrlKey, BuildConfig.SERVER_ADDRESS)
-        }
-    }
-
-    /**
-     * 
-     * 
-     * @param authenticationRequest 
-     * @return AuthenticationResponse
-     * @throws IllegalStateException If the request is not correctly configured
-     * @throws IOException Rethrows the OkHttp execute method exception
-     * @throws UnsupportedOperationException If the API returns an informational or redirection response
-     * @throws ClientException If the API returns a client error response
-     * @throws ServerException If the API returns a server error response
-     */
-    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
-    suspend fun authenticate(authenticationRequest: AuthenticationRequest) : AuthenticationResponse = withContext(Dispatchers.IO) {
-        val localVarResponse = authenticateWithHttpInfo(authenticationRequest = authenticationRequest)
-
-        return@withContext when (localVarResponse.responseType) {
-            ResponseType.Success -> (localVarResponse as Success<*>).data as AuthenticationResponse
-            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
-            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
-            ResponseType.ClientError -> {
-                val localVarError = localVarResponse as ClientError<*>
-                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
-            }
-            ResponseType.ServerError -> {
-                val localVarError = localVarResponse as ServerError<*>
-                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
-            }
-        }
-    }
-
-    /**
-     * 
-     * 
-     * @param authenticationRequest 
-     * @return ApiResponse<AuthenticationResponse?>
-     * @throws IllegalStateException If the request is not correctly configured
-     * @throws IOException Rethrows the OkHttp execute method exception
-     */
-    @Throws(IllegalStateException::class, IOException::class)
-    fun authenticateWithHttpInfo(authenticationRequest: AuthenticationRequest) : ApiResponse<AuthenticationResponse?> {
-        val localVariableConfig = authenticateRequestConfig(authenticationRequest = authenticationRequest)
-
-        return request<AuthenticationRequest, AuthenticationResponse>(
-            localVariableConfig
-        )
-    }
-
-    /**
-     * To obtain the request config of the operation authenticate
-     *
-     * @param authenticationRequest 
-     * @return RequestConfig
-     */
-    fun authenticateRequestConfig(authenticationRequest: AuthenticationRequest) : RequestConfig<AuthenticationRequest> {
-        val localVariableBody = authenticationRequest
-        val localVariableQuery: MultiValueMap = mutableMapOf()
-        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
-        localVariableHeaders["Content-Type"] = "application/json"
-        
-        return RequestConfig(
-            method = RequestMethod.POST,
-            path = "/api/users/authenticate",
-            query = localVariableQuery,
-            headers = localVariableHeaders,
-            requiresAuthentication = false,
-            body = localVariableBody
-        )
-    }
-
-    /**
-     * 
-     * 
-     * @param changePasswordRequest 
-     * @return kotlin.Any
-     * @throws IllegalStateException If the request is not correctly configured
-     * @throws IOException Rethrows the OkHttp execute method exception
-     * @throws UnsupportedOperationException If the API returns an informational or redirection response
-     * @throws ClientException If the API returns a client error response
-     * @throws ServerException If the API returns a server error response
-     */
-    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
-    suspend fun changePassword(changePasswordRequest: ChangePasswordRequest) : kotlin.Any = withContext(Dispatchers.IO){
-        val localVarResponse = changePasswordWithHttpInfo(changePasswordRequest = changePasswordRequest)
-
-        return@withContext when (localVarResponse.responseType) {
-            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
-            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
-            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
-            ResponseType.ClientError -> {
-                val localVarError = localVarResponse as ClientError<*>
-                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
-            }
-
-            ResponseType.ServerError -> {
-                val localVarError = localVarResponse as ServerError<*>
-                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
-            }
-        }
-    }
-
-    /**
-     * 
-     * 
-     * @param changePasswordRequest 
-     * @return ApiResponse<kotlin.Any?>
-     * @throws IllegalStateException If the request is not correctly configured
-     * @throws IOException Rethrows the OkHttp execute method exception
-     */
-    @Throws(IllegalStateException::class, IOException::class)
-    fun changePasswordWithHttpInfo(changePasswordRequest: ChangePasswordRequest) : ApiResponse<kotlin.Any?> {
-        val localVariableConfig = changePasswordRequestConfig(changePasswordRequest = changePasswordRequest)
-
-        return request<ChangePasswordRequest, kotlin.Any>(
-            localVariableConfig
-        )
-    }
-
-    /**
-     * To obtain the request config of the operation changePassword
-     *
-     * @param changePasswordRequest 
-     * @return RequestConfig
-     */
-    fun changePasswordRequestConfig(changePasswordRequest: ChangePasswordRequest) : RequestConfig<ChangePasswordRequest> {
-        val localVariableBody = changePasswordRequest
-        val localVariableQuery: MultiValueMap = mutableMapOf()
-        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
-        localVariableHeaders["Content-Type"] = "application/json"
-        
-        return RequestConfig(
-            method = RequestMethod.PATCH,
-            path = "/api/users",
-            query = localVariableQuery,
-            headers = localVariableHeaders,
-            requiresAuthentication = true,
-            body = localVariableBody
-        )
-    }
-
-    /**
-     * 
-     * 
-     * @return void
-     * @throws IllegalStateException If the request is not correctly configured
-     * @throws IOException Rethrows the OkHttp execute method exception
-     * @throws UnsupportedOperationException If the API returns an informational or redirection response
-     * @throws ClientException If the API returns a client error response
-     * @throws ServerException If the API returns a server error response
-     */
-    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
-    suspend fun refreshToken() = withContext(Dispatchers.IO){
-        val localVarResponse = refreshTokenWithHttpInfo()
-
-        return@withContext when (localVarResponse.responseType) {
-            ResponseType.Success -> Unit
-            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
-            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
-            ResponseType.ClientError -> {
-                val localVarError = localVarResponse as ClientError<*>
-                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
-            }
-
-            ResponseType.ServerError -> {
-                val localVarError = localVarResponse as ServerError<*>
-                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
-            }
-        }
-    }
-
-    /**
-     * 
-     * 
-     * @return ApiResponse<Unit?>
-     * @throws IllegalStateException If the request is not correctly configured
-     * @throws IOException Rethrows the OkHttp execute method exception
-     */
-    @Throws(IllegalStateException::class, IOException::class)
-    fun refreshTokenWithHttpInfo() : ApiResponse<Unit?> {
-        val localVariableConfig = refreshTokenRequestConfig()
-
-        return request<Unit, Unit>(
-            localVariableConfig
-        )
-    }
-
-    /**
-     * To obtain the request config of the operation refreshToken
-     *
-     * @return RequestConfig
-     */
-    fun refreshTokenRequestConfig() : RequestConfig<Unit> {
-        val localVariableBody = null
-        val localVariableQuery: MultiValueMap = mutableMapOf()
-        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
-        
-        return RequestConfig(
-            method = RequestMethod.POST,
-            path = "/api/users/refresh-token",
-            query = localVariableQuery,
-            headers = localVariableHeaders,
-            requiresAuthentication = true,
-            body = localVariableBody
-        )
-    }
-
-    /**
-     * 
-     * 
-     * @param registerRequest 
-     * @return AuthenticationResponse
-     * @throws IllegalStateException If the request is not correctly configured
-     * @throws IOException Rethrows the OkHttp execute method exception
-     * @throws UnsupportedOperationException If the API returns an informational or redirection response
-     * @throws ClientException If the API returns a client error response
-     * @throws ServerException If the API returns a server error response
-     */
-    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
-    suspend fun register(registerRequest: RegisterRequest) : AuthenticationResponse = withContext(Dispatchers.IO) {
-        val localVarResponse = registerWithHttpInfo(registerRequest = registerRequest)
-
-        return@withContext when (localVarResponse.responseType) {
-            ResponseType.Success -> (localVarResponse as Success<*>).data as AuthenticationResponse
-            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
-            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
-            ResponseType.ClientError -> {
-                val localVarError = localVarResponse as ClientError<*>
-                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
-            }
-
-            ResponseType.ServerError -> {
-                val localVarError = localVarResponse as ServerError<*>
-                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
-            }
-        }
-    }
-
-    /**
-     * 
-     * 
-     * @param registerRequest 
-     * @return ApiResponse<AuthenticationResponse?>
-     * @throws IllegalStateException If the request is not correctly configured
-     * @throws IOException Rethrows the OkHttp execute method exception
-     */
-    @Throws(IllegalStateException::class, IOException::class)
-    fun registerWithHttpInfo(registerRequest: RegisterRequest) : ApiResponse<AuthenticationResponse?> {
-        val localVariableConfig = registerRequestConfig(registerRequest = registerRequest)
-
-        return request<RegisterRequest, AuthenticationResponse>(
-            localVariableConfig
-        )
-    }
-
-    /**
-     * To obtain the request config of the operation register
-     *
-     * @param registerRequest 
-     * @return RequestConfig
-     */
-    fun registerRequestConfig(registerRequest: RegisterRequest) : RequestConfig<RegisterRequest> {
-        val localVariableBody = registerRequest
-        val localVariableQuery: MultiValueMap = mutableMapOf()
-        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
-        localVariableHeaders["Content-Type"] = "application/json"
-        
-        return RequestConfig(
-            method = RequestMethod.POST,
-            path = "/api/users/register",
-            query = localVariableQuery,
-            headers = localVariableHeaders,
-            requiresAuthentication = false,
-            body = localVariableBody
-        )
-    }
-}
diff --git a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/apis/WishlistControllerApi.kt b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/apis/WishlistControllerApi.kt
index a98f63a..f70e214 100644
--- a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/apis/WishlistControllerApi.kt
+++ b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/apis/WishlistControllerApi.kt
@@ -13,22 +13,26 @@
     "UnusedImport",
 )
 
-package org.openapitools.client.apis
+package it.unical.informatica.ea.sefora_frontend.apis
 
+import it.unical.informatica.ea.sefora_frontend.BuildConfig
+import kotlinx.coroutines.Dispatchers
+import kotlinx.coroutines.runBlocking
 import okhttp3.HttpUrl
 import okhttp3.OkHttpClient
-import org.openapitools.client.infrastructure.ApiClient
-import org.openapitools.client.infrastructure.ApiResponse
-import org.openapitools.client.infrastructure.ClientError
-import org.openapitools.client.infrastructure.ClientException
-import org.openapitools.client.infrastructure.MultiValueMap
-import org.openapitools.client.infrastructure.RequestConfig
-import org.openapitools.client.infrastructure.RequestMethod
-import org.openapitools.client.infrastructure.ResponseType
-import org.openapitools.client.infrastructure.ServerError
-import org.openapitools.client.infrastructure.ServerException
-import org.openapitools.client.infrastructure.Success
-import org.openapitools.client.models.WishlistDto
+import it.unical.informatica.ea.sefora_frontend.infrastructure.ApiClient
+import it.unical.informatica.ea.sefora_frontend.infrastructure.ApiResponse
+import it.unical.informatica.ea.sefora_frontend.infrastructure.ClientError
+import it.unical.informatica.ea.sefora_frontend.infrastructure.ClientException
+import it.unical.informatica.ea.sefora_frontend.infrastructure.MultiValueMap
+import it.unical.informatica.ea.sefora_frontend.infrastructure.RequestConfig
+import it.unical.informatica.ea.sefora_frontend.infrastructure.RequestMethod
+import it.unical.informatica.ea.sefora_frontend.infrastructure.ResponseType
+import it.unical.informatica.ea.sefora_frontend.infrastructure.ServerError
+import it.unical.informatica.ea.sefora_frontend.infrastructure.ServerException
+import it.unical.informatica.ea.sefora_frontend.infrastructure.Success
+import it.unical.informatica.ea.sefora_frontend.models.WishlistDto
+import kotlinx.coroutines.withContext
 import java.io.IOException
 
 class WishlistControllerApi(
@@ -38,14 +42,13 @@ class WishlistControllerApi(
     companion object {
         @JvmStatic
         val defaultBasePath: String by lazy {
-            System.getProperties().getProperty(ApiClient.baseUrlKey, "http://localhost:8080")
+            System.getProperties().getProperty(ApiClient.baseUrlKey, BuildConfig.SERVER_ADDRESS)
         }
     }
 
     /**
      *
      *
-     * @param wishlistId
      * @param productId
      * @return kotlin.String
      * @throws IllegalStateException If the request is not correctly configured
@@ -62,14 +65,11 @@ class WishlistControllerApi(
         ClientException::class,
         ServerException::class,
     )
-    fun addProductToWishlist(
-        wishlistId: kotlin.Long,
-        productId: kotlin.Long,
-    ): kotlin.String {
-        val localVarResponse = addProductToWishlistWithHttpInfo(wishlistId = wishlistId, productId = productId)
+    suspend fun addProductToWishlist(productId: kotlin.Long, token: String) = withContext(Dispatchers.IO){
+        val localVarResponse = addProductToWishlistWithHttpInfo(productId = productId, token = token)
 
-        return when (localVarResponse.responseType) {
-            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.String
+        return@withContext when (localVarResponse.responseType) {
+            ResponseType.Success -> (localVarResponse as Success<*>)
             ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
             ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
             ResponseType.ClientError -> {
@@ -94,7 +94,6 @@ class WishlistControllerApi(
     /**
      *
      *
-     * @param wishlistId
      * @param productId
      * @return ApiResponse<kotlin.String?>
      * @throws IllegalStateException If the request is not correctly configured
@@ -102,11 +101,8 @@ class WishlistControllerApi(
      */
     @Suppress("UNCHECKED_CAST")
     @Throws(IllegalStateException::class, IOException::class)
-    fun addProductToWishlistWithHttpInfo(
-        wishlistId: kotlin.Long,
-        productId: kotlin.Long,
-    ): ApiResponse<kotlin.String?> {
-        val localVariableConfig = addProductToWishlistRequestConfig(wishlistId = wishlistId, productId = productId)
+    fun addProductToWishlistWithHttpInfo(productId: kotlin.Long, token: String): ApiResponse<kotlin.String?> {
+        val localVariableConfig = addProductToWishlistRequestConfig(productId = productId, token = token)
 
         return request<Unit, kotlin.String>(
             localVariableConfig,
@@ -116,23 +112,20 @@ class WishlistControllerApi(
     /**
      * To obtain the request config of the operation addProductToWishlist
      *
-     * @param wishlistId
      * @param productId
      * @return RequestConfig
      */
-    fun addProductToWishlistRequestConfig(
-        wishlistId: kotlin.Long,
-        productId: kotlin.Long,
-    ): RequestConfig<Unit> {
+    fun addProductToWishlistRequestConfig(productId: kotlin.Long, token : String): RequestConfig<Unit> {
         val localVariableBody = null
         val localVariableQuery: MultiValueMap =
             mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
                 .apply {
-                    put("wishlistId", listOf(wishlistId.toString()))
                     put("productId", listOf(productId.toString()))
                 }
         val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
 
+        localVariableHeaders["Authorization"] = "Bearer $token"
+
         return RequestConfig(
             method = RequestMethod.PATCH,
             path = "/api/wishlist/addProduct",
@@ -146,7 +139,96 @@ class WishlistControllerApi(
     /**
      *
      *
-     * @param wishlistId
+     * @param userEmail
+     * @return kotlin.String
+     * @throws IllegalStateException If the request is not correctly configured
+     * @throws IOException Rethrows the OkHttp execute method exception
+     * @throws UnsupportedOperationException If the API returns an informational or redirection response
+     * @throws ClientException If the API returns a client error response
+     * @throws ServerException If the API returns a server error response
+     */
+    @Suppress("UNCHECKED_CAST")
+    @Throws(
+        IllegalStateException::class,
+        IOException::class,
+        UnsupportedOperationException::class,
+        ClientException::class,
+        ServerException::class,
+    )
+    fun addUserThroughEmailToWishlist(userEmail: kotlin.String, token : String) = runBlocking(Dispatchers.IO) {
+        val localVarResponse = addUserThroughEmailToWishlistWithHttpInfo(userEmail = userEmail, token = token)
+
+        return@runBlocking when (localVarResponse.responseType) {
+            ResponseType.Success -> (localVarResponse as Success<*>)
+            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
+            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
+            ResponseType.ClientError -> {
+                val localVarError = localVarResponse as ClientError<*>
+                throw ClientException(
+                    "Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}",
+                    localVarError.statusCode,
+                    localVarResponse,
+                )
+            }
+            ResponseType.ServerError -> {
+                val localVarError = localVarResponse as ServerError<*>
+                throw ServerException(
+                    "Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}",
+                    localVarError.statusCode,
+                    localVarResponse,
+                )
+            }
+        }
+    }
+
+    /**
+     *
+     *
+     * @param userEmail
+     * @return ApiResponse<kotlin.String?>
+     * @throws IllegalStateException If the request is not correctly configured
+     * @throws IOException Rethrows the OkHttp execute method exception
+     */
+    @Suppress("UNCHECKED_CAST")
+    @Throws(IllegalStateException::class, IOException::class)
+    fun addUserThroughEmailToWishlistWithHttpInfo(userEmail: kotlin.String, token: String): ApiResponse<kotlin.String?> {
+        val localVariableConfig = addUserThroughEmailToWishlistRequestConfig(userEmail = userEmail, token = token)
+
+        return request<Unit, kotlin.String>(
+            localVariableConfig,
+        )
+    }
+
+    /**
+     * To obtain the request config of the operation addUserThroughEmailToWishlist
+     *
+     * @param userEmail
+     * @return RequestConfig
+     */
+    fun addUserThroughEmailToWishlistRequestConfig(userEmail: kotlin.String, token : String): RequestConfig<Unit> {
+        val localVariableBody = null
+        val localVariableQuery: MultiValueMap =
+            mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
+                .apply {
+                    put("userEmail", listOf(userEmail.toString()))
+                }
+        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
+
+        localVariableHeaders["Authorization"] = "Bearer $token"
+
+        return RequestConfig(
+            method = RequestMethod.PATCH,
+            path = "/api/wishlist/addUserByEmail",
+            query = localVariableQuery,
+            headers = localVariableHeaders,
+            requiresAuthentication = true,
+            body = localVariableBody,
+        )
+    }
+
+    /**
+     *
+     *
      * @param userId
      * @return kotlin.String
      * @throws IllegalStateException If the request is not correctly configured
@@ -163,13 +245,10 @@ class WishlistControllerApi(
         ClientException::class,
         ServerException::class,
     )
-    fun addUserToWishlist(
-        wishlistId: kotlin.Long,
-        userId: kotlin.Long,
-    ): kotlin.String {
-        val localVarResponse = addUserToWishlistWithHttpInfo(wishlistId = wishlistId, userId = userId)
+    fun addUserToWishlist(userId: kotlin.Long, token: String): kotlin.String  = runBlocking(Dispatchers.IO) {
+        val localVarResponse = addUserToWishlistWithHttpInfo(userId = userId, token = token)
 
-        return when (localVarResponse.responseType) {
+        return@runBlocking when (localVarResponse.responseType) {
             ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.String
             ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
             ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
@@ -195,7 +274,6 @@ class WishlistControllerApi(
     /**
      *
      *
-     * @param wishlistId
      * @param userId
      * @return ApiResponse<kotlin.String?>
      * @throws IllegalStateException If the request is not correctly configured
@@ -203,11 +281,8 @@ class WishlistControllerApi(
      */
     @Suppress("UNCHECKED_CAST")
     @Throws(IllegalStateException::class, IOException::class)
-    fun addUserToWishlistWithHttpInfo(
-        wishlistId: kotlin.Long,
-        userId: kotlin.Long,
-    ): ApiResponse<kotlin.String?> {
-        val localVariableConfig = addUserToWishlistRequestConfig(wishlistId = wishlistId, userId = userId)
+    fun addUserToWishlistWithHttpInfo(userId: kotlin.Long, token: String): ApiResponse<kotlin.String?> {
+        val localVariableConfig = addUserToWishlistRequestConfig(userId = userId, token = token)
 
         return request<Unit, kotlin.String>(
             localVariableConfig,
@@ -217,23 +292,20 @@ class WishlistControllerApi(
     /**
      * To obtain the request config of the operation addUserToWishlist
      *
-     * @param wishlistId
      * @param userId
      * @return RequestConfig
      */
-    fun addUserToWishlistRequestConfig(
-        wishlistId: kotlin.Long,
-        userId: kotlin.Long,
-    ): RequestConfig<Unit> {
+    fun addUserToWishlistRequestConfig(userId: kotlin.Long, token: String): RequestConfig<Unit> {
         val localVariableBody = null
         val localVariableQuery: MultiValueMap =
             mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
                 .apply {
-                    put("wishlistId", listOf(wishlistId.toString()))
                     put("userId", listOf(userId.toString()))
                 }
         val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
 
+        localVariableHeaders["Authorization"] = "Bearer $token"
+
         return RequestConfig(
             method = RequestMethod.PATCH,
             path = "/api/wishlist/addUser",
@@ -263,10 +335,10 @@ class WishlistControllerApi(
         ClientException::class,
         ServerException::class,
     )
-    fun createWishlist(wishlistDto: WishlistDto): WishlistDto {
-        val localVarResponse = createWishlistWithHttpInfo(wishlistDto = wishlistDto)
+    fun createWishlist(wishlistDto: WishlistDto, token: String): WishlistDto  = runBlocking(Dispatchers.IO) {
+        val localVarResponse = createWishlistWithHttpInfo(wishlistDto = wishlistDto, token = token)
 
-        return when (localVarResponse.responseType) {
+        return@runBlocking when (localVarResponse.responseType) {
             ResponseType.Success -> (localVarResponse as Success<*>).data as WishlistDto
             ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
             ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
@@ -299,8 +371,8 @@ class WishlistControllerApi(
      */
     @Suppress("UNCHECKED_CAST")
     @Throws(IllegalStateException::class, IOException::class)
-    fun createWishlistWithHttpInfo(wishlistDto: WishlistDto): ApiResponse<WishlistDto?> {
-        val localVariableConfig = createWishlistRequestConfig(wishlistDto = wishlistDto)
+    fun createWishlistWithHttpInfo(wishlistDto: WishlistDto, token: String): ApiResponse<WishlistDto?> {
+        val localVariableConfig = createWishlistRequestConfig(wishlistDto = wishlistDto, token = token)
 
         return request<WishlistDto, WishlistDto>(
             localVariableConfig,
@@ -313,12 +385,14 @@ class WishlistControllerApi(
      * @param wishlistDto
      * @return RequestConfig
      */
-    fun createWishlistRequestConfig(wishlistDto: WishlistDto): RequestConfig<WishlistDto> {
+    fun createWishlistRequestConfig(wishlistDto: WishlistDto, token: String): RequestConfig<WishlistDto> {
         val localVariableBody = wishlistDto
         val localVariableQuery: MultiValueMap = mutableMapOf()
         val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
         localVariableHeaders["Content-Type"] = "application/json"
 
+        localVariableHeaders["Authorization"] = "Bearer $token"
+
         return RequestConfig(
             method = RequestMethod.POST,
             path = "/api/wishlist",
@@ -348,10 +422,10 @@ class WishlistControllerApi(
         ClientException::class,
         ServerException::class,
     )
-    fun deleteWishlist(id: kotlin.Long): kotlin.String {
-        val localVarResponse = deleteWishlistWithHttpInfo(id = id)
+    fun deleteWishlist(id: kotlin.Long, token: String): kotlin.String  = runBlocking(Dispatchers.IO) {
+        val localVarResponse = deleteWishlistWithHttpInfo(id = id, token = token)
 
-        return when (localVarResponse.responseType) {
+        return@runBlocking when (localVarResponse.responseType) {
             ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.String
             ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
             ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
@@ -384,8 +458,8 @@ class WishlistControllerApi(
      */
     @Suppress("UNCHECKED_CAST")
     @Throws(IllegalStateException::class, IOException::class)
-    fun deleteWishlistWithHttpInfo(id: kotlin.Long): ApiResponse<kotlin.String?> {
-        val localVariableConfig = deleteWishlistRequestConfig(id = id)
+    fun deleteWishlistWithHttpInfo(id: kotlin.Long, token: String): ApiResponse<kotlin.String?> {
+        val localVariableConfig = deleteWishlistRequestConfig(id = id, token = token)
 
         return request<Unit, kotlin.String>(
             localVariableConfig,
@@ -398,11 +472,13 @@ class WishlistControllerApi(
      * @param id
      * @return RequestConfig
      */
-    fun deleteWishlistRequestConfig(id: kotlin.Long): RequestConfig<Unit> {
+    fun deleteWishlistRequestConfig(id: kotlin.Long, token: String): RequestConfig<Unit> {
         val localVariableBody = null
         val localVariableQuery: MultiValueMap = mutableMapOf()
         val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
 
+        localVariableHeaders["Authorization"] = "Bearer $token"
+
         return RequestConfig(
             method = RequestMethod.DELETE,
             path = "/api/wishlist/{id}".replace("{" + "id" + "}", encodeURIComponent(id.toString())),
@@ -431,10 +507,10 @@ class WishlistControllerApi(
         ClientException::class,
         ServerException::class,
     )
-    fun getCurrentUserWishlists(): kotlin.collections.List<WishlistDto> {
-        val localVarResponse = getCurrentUserWishlistsWithHttpInfo()
+    suspend fun getAllAccessibleWishlists(token: String): kotlin.collections.List<WishlistDto> = withContext(Dispatchers.IO) {
+        val localVarResponse = getAllAccessibleWishlistsWithHttpInfo(token = token)
 
-        return when (localVarResponse.responseType) {
+        return@withContext when (localVarResponse.responseType) {
             ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<WishlistDto>
             ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
             ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
@@ -466,8 +542,91 @@ class WishlistControllerApi(
      */
     @Suppress("UNCHECKED_CAST")
     @Throws(IllegalStateException::class, IOException::class)
-    fun getCurrentUserWishlistsWithHttpInfo(): ApiResponse<kotlin.collections.List<WishlistDto>?> {
-        val localVariableConfig = getCurrentUserWishlistsRequestConfig()
+    fun getAllAccessibleWishlistsWithHttpInfo(token: String): ApiResponse<kotlin.collections.List<WishlistDto>?> {
+        val localVariableConfig = getAllAccessibleWishlistsRequestConfig(token = token)
+
+        return request<Unit, kotlin.collections.List<WishlistDto>>(
+            localVariableConfig,
+        )
+    }
+
+    /**
+     * To obtain the request config of the operation getAllAccessibleWishlists
+     *
+     * @return RequestConfig
+     */
+    fun getAllAccessibleWishlistsRequestConfig(token: String): RequestConfig<Unit> {
+        val localVariableBody = null
+        val localVariableQuery: MultiValueMap = mutableMapOf()
+        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
+
+        localVariableHeaders["Authorization"] = "Bearer $token"
+
+        return RequestConfig(
+            method = RequestMethod.GET,
+            path = "/api/wishlist/accessible",
+            query = localVariableQuery,
+            headers = localVariableHeaders,
+            requiresAuthentication = true,
+            body = localVariableBody,
+        )
+    }
+
+    /**
+     *
+     *
+     * @return kotlin.collections.List<WishlistDto>
+     * @throws IllegalStateException If the request is not correctly configured
+     * @throws IOException Rethrows the OkHttp execute method exception
+     * @throws UnsupportedOperationException If the API returns an informational or redirection response
+     * @throws ClientException If the API returns a client error response
+     * @throws ServerException If the API returns a server error response
+     */
+    @Suppress("UNCHECKED_CAST")
+    @Throws(
+        IllegalStateException::class,
+        IOException::class,
+        UnsupportedOperationException::class,
+        ClientException::class,
+        ServerException::class,
+    )
+    fun getCurrentUserWishlists(token: String): kotlin.collections.List<WishlistDto>  = runBlocking(Dispatchers.IO) {
+        val localVarResponse = getCurrentUserWishlistsWithHttpInfo(token = token)
+
+        return@runBlocking when (localVarResponse.responseType) {
+            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<WishlistDto>
+            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
+            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
+            ResponseType.ClientError -> {
+                val localVarError = localVarResponse as ClientError<*>
+                throw ClientException(
+                    "Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}",
+                    localVarError.statusCode,
+                    localVarResponse,
+                )
+            }
+            ResponseType.ServerError -> {
+                val localVarError = localVarResponse as ServerError<*>
+                throw ServerException(
+                    "Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}",
+                    localVarError.statusCode,
+                    localVarResponse,
+                )
+            }
+        }
+    }
+
+    /**
+     *
+     *
+     * @return ApiResponse<kotlin.collections.List<WishlistDto>?>
+     * @throws IllegalStateException If the request is not correctly configured
+     * @throws IOException Rethrows the OkHttp execute method exception
+     */
+    @Suppress("UNCHECKED_CAST")
+    @Throws(IllegalStateException::class, IOException::class)
+    fun getCurrentUserWishlistsWithHttpInfo(token: String): ApiResponse<kotlin.collections.List<WishlistDto>?> {
+        val localVariableConfig = getCurrentUserWishlistsRequestConfig(token = token)
 
         return request<Unit, kotlin.collections.List<WishlistDto>>(
             localVariableConfig,
@@ -479,11 +638,13 @@ class WishlistControllerApi(
      *
      * @return RequestConfig
      */
-    fun getCurrentUserWishlistsRequestConfig(): RequestConfig<Unit> {
+    fun getCurrentUserWishlistsRequestConfig(token: String): RequestConfig<Unit> {
         val localVariableBody = null
         val localVariableQuery: MultiValueMap = mutableMapOf()
         val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
 
+        localVariableHeaders["Authorization"] = "Bearer $token"
+
         return RequestConfig(
             method = RequestMethod.GET,
             path = "/api/wishlist/current",
@@ -494,6 +655,89 @@ class WishlistControllerApi(
         )
     }
 
+    /**
+     *
+     *
+     * @return WishlistDto
+     * @throws IllegalStateException If the request is not correctly configured
+     * @throws IOException Rethrows the OkHttp execute method exception
+     * @throws UnsupportedOperationException If the API returns an informational or redirection response
+     * @throws ClientException If the API returns a client error response
+     * @throws ServerException If the API returns a server error response
+     */
+    @Suppress("UNCHECKED_CAST")
+    @Throws(
+        IllegalStateException::class,
+        IOException::class,
+        UnsupportedOperationException::class,
+        ClientException::class,
+        ServerException::class,
+    )
+    fun getPersonalWishlist(token: String): WishlistDto = runBlocking(Dispatchers.IO){
+        val localVarResponse = getPersonalWishlistWithHttpInfo(token = token)
+
+        return@runBlocking when (localVarResponse.responseType) {
+            ResponseType.Success -> (localVarResponse as Success<*>).data as WishlistDto
+            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
+            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
+            ResponseType.ClientError -> {
+                val localVarError = localVarResponse as ClientError<*>
+                throw ClientException(
+                    "Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}",
+                    localVarError.statusCode,
+                    localVarResponse,
+                )
+            }
+            ResponseType.ServerError -> {
+                val localVarError = localVarResponse as ServerError<*>
+                throw ServerException(
+                    "Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}",
+                    localVarError.statusCode,
+                    localVarResponse,
+                )
+            }
+        }
+    }
+
+    /**
+     *
+     *
+     * @return ApiResponse<WishlistDto?>
+     * @throws IllegalStateException If the request is not correctly configured
+     * @throws IOException Rethrows the OkHttp execute method exception
+     */
+    @Suppress("UNCHECKED_CAST")
+    @Throws(IllegalStateException::class, IOException::class)
+    fun getPersonalWishlistWithHttpInfo(token: String): ApiResponse<WishlistDto?> {
+        val localVariableConfig = getPersonalWishlistRequestConfig(token = token)
+
+        return request<Unit, WishlistDto>(
+            localVariableConfig,
+        )
+    }
+
+    /**
+     * To obtain the request config of the operation getPersonalWishlist
+     *
+     * @return RequestConfig
+     */
+    fun getPersonalWishlistRequestConfig(token: String): RequestConfig<Unit> {
+        val localVariableBody = null
+        val localVariableQuery: MultiValueMap = mutableMapOf()
+        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
+
+        localVariableHeaders["Authorization"] = "Bearer $token"
+
+        return RequestConfig(
+            method = RequestMethod.GET,
+            path = "/api/wishlist/personal",
+            query = localVariableQuery,
+            headers = localVariableHeaders,
+            requiresAuthentication = true,
+            body = localVariableBody,
+        )
+    }
+
     /**
      *
      *
@@ -512,10 +756,10 @@ class WishlistControllerApi(
         ClientException::class,
         ServerException::class,
     )
-    fun getSharedWishlists(): kotlin.collections.List<WishlistDto> {
-        val localVarResponse = getSharedWishlistsWithHttpInfo()
+    fun getSharedWishlists(token: String): kotlin.collections.List<WishlistDto> = runBlocking(Dispatchers.IO) {
+        val localVarResponse = getSharedWishlistsWithHttpInfo(token = token)
 
-        return when (localVarResponse.responseType) {
+        return@runBlocking when (localVarResponse.responseType) {
             ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<WishlistDto>
             ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
             ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
@@ -547,8 +791,8 @@ class WishlistControllerApi(
      */
     @Suppress("UNCHECKED_CAST")
     @Throws(IllegalStateException::class, IOException::class)
-    fun getSharedWishlistsWithHttpInfo(): ApiResponse<kotlin.collections.List<WishlistDto>?> {
-        val localVariableConfig = getSharedWishlistsRequestConfig()
+    fun getSharedWishlistsWithHttpInfo(token: String): ApiResponse<kotlin.collections.List<WishlistDto>?> {
+        val localVariableConfig = getSharedWishlistsRequestConfig(token = token)
 
         return request<Unit, kotlin.collections.List<WishlistDto>>(
             localVariableConfig,
@@ -560,11 +804,13 @@ class WishlistControllerApi(
      *
      * @return RequestConfig
      */
-    fun getSharedWishlistsRequestConfig(): RequestConfig<Unit> {
+    fun getSharedWishlistsRequestConfig(token: String): RequestConfig<Unit> {
         val localVariableBody = null
         val localVariableQuery: MultiValueMap = mutableMapOf()
         val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
 
+        localVariableHeaders["Authorization"] = "Bearer $token"
+
         return RequestConfig(
             method = RequestMethod.GET,
             path = "/api/wishlist/shared",
@@ -662,7 +908,6 @@ class WishlistControllerApi(
     /**
      *
      *
-     * @param wishlistId
      * @param productId
      * @return kotlin.String
      * @throws IllegalStateException If the request is not correctly configured
@@ -679,14 +924,11 @@ class WishlistControllerApi(
         ClientException::class,
         ServerException::class,
     )
-    fun removeProductFromWishlist(
-        wishlistId: kotlin.Long,
-        productId: kotlin.Long,
-    ): kotlin.String {
-        val localVarResponse = removeProductFromWishlistWithHttpInfo(wishlistId = wishlistId, productId = productId)
+    fun removeProductFromWishlist(productId: kotlin.Long, token: String) = runBlocking(Dispatchers.IO) {
+        val localVarResponse = removeProductFromWishlistWithHttpInfo(productId = productId, token = token)
 
-        return when (localVarResponse.responseType) {
-            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.String
+        return@runBlocking when (localVarResponse.responseType) {
+            ResponseType.Success -> (localVarResponse as Success<*>)
             ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
             ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
             ResponseType.ClientError -> {
@@ -711,7 +953,6 @@ class WishlistControllerApi(
     /**
      *
      *
-     * @param wishlistId
      * @param productId
      * @return ApiResponse<kotlin.String?>
      * @throws IllegalStateException If the request is not correctly configured
@@ -719,11 +960,8 @@ class WishlistControllerApi(
      */
     @Suppress("UNCHECKED_CAST")
     @Throws(IllegalStateException::class, IOException::class)
-    fun removeProductFromWishlistWithHttpInfo(
-        wishlistId: kotlin.Long,
-        productId: kotlin.Long,
-    ): ApiResponse<kotlin.String?> {
-        val localVariableConfig = removeProductFromWishlistRequestConfig(wishlistId = wishlistId, productId = productId)
+    fun removeProductFromWishlistWithHttpInfo(productId: kotlin.Long, token: String): ApiResponse<kotlin.String?> {
+        val localVariableConfig = removeProductFromWishlistRequestConfig(productId = productId, token = token)
 
         return request<Unit, kotlin.String>(
             localVariableConfig,
@@ -733,23 +971,20 @@ class WishlistControllerApi(
     /**
      * To obtain the request config of the operation removeProductFromWishlist
      *
-     * @param wishlistId
      * @param productId
      * @return RequestConfig
      */
-    fun removeProductFromWishlistRequestConfig(
-        wishlistId: kotlin.Long,
-        productId: kotlin.Long,
-    ): RequestConfig<Unit> {
+    fun removeProductFromWishlistRequestConfig(productId: kotlin.Long, token: String): RequestConfig<Unit> {
         val localVariableBody = null
         val localVariableQuery: MultiValueMap =
             mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
                 .apply {
-                    put("wishlistId", listOf(wishlistId.toString()))
                     put("productId", listOf(productId.toString()))
                 }
         val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
 
+        localVariableHeaders["Authorization"] = "Bearer $token"
+
         return RequestConfig(
             method = RequestMethod.PATCH,
             path = "/api/wishlist/removeProduct",
@@ -763,7 +998,6 @@ class WishlistControllerApi(
     /**
      *
      *
-     * @param wishlistId
      * @param userId
      * @return kotlin.String
      * @throws IllegalStateException If the request is not correctly configured
@@ -780,14 +1014,11 @@ class WishlistControllerApi(
         ClientException::class,
         ServerException::class,
     )
-    fun removeUserFromWishlist(
-        wishlistId: kotlin.Long,
-        userId: kotlin.Long,
-    ): kotlin.String {
-        val localVarResponse = removeUserFromWishlistWithHttpInfo(wishlistId = wishlistId, userId = userId)
+    fun removeUserFromWishlist(userId: kotlin.Long, token: String) = runBlocking(Dispatchers.IO) {
+        val localVarResponse = removeUserFromWishlistWithHttpInfo(userId = userId, token = token)
 
-        return when (localVarResponse.responseType) {
-            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.String
+        return@runBlocking when (localVarResponse.responseType) {
+            ResponseType.Success -> (localVarResponse as Success<*>)
             ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
             ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
             ResponseType.ClientError -> {
@@ -812,7 +1043,6 @@ class WishlistControllerApi(
     /**
      *
      *
-     * @param wishlistId
      * @param userId
      * @return ApiResponse<kotlin.String?>
      * @throws IllegalStateException If the request is not correctly configured
@@ -820,11 +1050,8 @@ class WishlistControllerApi(
      */
     @Suppress("UNCHECKED_CAST")
     @Throws(IllegalStateException::class, IOException::class)
-    fun removeUserFromWishlistWithHttpInfo(
-        wishlistId: kotlin.Long,
-        userId: kotlin.Long,
-    ): ApiResponse<kotlin.String?> {
-        val localVariableConfig = removeUserFromWishlistRequestConfig(wishlistId = wishlistId, userId = userId)
+    fun removeUserFromWishlistWithHttpInfo(userId: kotlin.Long, token: String): ApiResponse<kotlin.String?> {
+        val localVariableConfig = removeUserFromWishlistRequestConfig(userId = userId, token = token)
 
         return request<Unit, kotlin.String>(
             localVariableConfig,
@@ -834,23 +1061,20 @@ class WishlistControllerApi(
     /**
      * To obtain the request config of the operation removeUserFromWishlist
      *
-     * @param wishlistId
      * @param userId
      * @return RequestConfig
      */
-    fun removeUserFromWishlistRequestConfig(
-        wishlistId: kotlin.Long,
-        userId: kotlin.Long,
-    ): RequestConfig<Unit> {
+    fun removeUserFromWishlistRequestConfig(userId: kotlin.Long, token: String): RequestConfig<Unit> {
         val localVariableBody = null
         val localVariableQuery: MultiValueMap =
             mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
                 .apply {
-                    put("wishlistId", listOf(wishlistId.toString()))
                     put("userId", listOf(userId.toString()))
                 }
         val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
 
+        localVariableHeaders["Authorization"] = "Bearer $token"
+
         return RequestConfig(
             method = RequestMethod.PATCH,
             path = "/api/wishlist/removeUser",
@@ -880,10 +1104,10 @@ class WishlistControllerApi(
         ClientException::class,
         ServerException::class,
     )
-    fun updateWishlist(wishlistDto: WishlistDto): kotlin.String {
-        val localVarResponse = updateWishlistWithHttpInfo(wishlistDto = wishlistDto)
+    fun updateWishlist(wishlistDto: WishlistDto, token: String): kotlin.String  = runBlocking(Dispatchers.IO) {
+        val localVarResponse = updateWishlistWithHttpInfo(wishlistDto = wishlistDto, token = token)
 
-        return when (localVarResponse.responseType) {
+        return@runBlocking when (localVarResponse.responseType) {
             ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.String
             ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
             ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
@@ -916,8 +1140,8 @@ class WishlistControllerApi(
      */
     @Suppress("UNCHECKED_CAST")
     @Throws(IllegalStateException::class, IOException::class)
-    fun updateWishlistWithHttpInfo(wishlistDto: WishlistDto): ApiResponse<kotlin.String?> {
-        val localVariableConfig = updateWishlistRequestConfig(wishlistDto = wishlistDto)
+    fun updateWishlistWithHttpInfo(wishlistDto: WishlistDto, token: String): ApiResponse<kotlin.String?> {
+        val localVariableConfig = updateWishlistRequestConfig(wishlistDto = wishlistDto, token = token)
 
         return request<WishlistDto, kotlin.String>(
             localVariableConfig,
@@ -930,12 +1154,14 @@ class WishlistControllerApi(
      * @param wishlistDto
      * @return RequestConfig
      */
-    fun updateWishlistRequestConfig(wishlistDto: WishlistDto): RequestConfig<WishlistDto> {
+    fun updateWishlistRequestConfig(wishlistDto: WishlistDto, token: String): RequestConfig<WishlistDto> {
         val localVariableBody = wishlistDto
         val localVariableQuery: MultiValueMap = mutableMapOf()
         val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
         localVariableHeaders["Content-Type"] = "application/json"
 
+        localVariableHeaders["Authorization"] = "Bearer $token"
+
         return RequestConfig(
             method = RequestMethod.PUT,
             path = "/api/wishlist",
@@ -954,4 +1180,4 @@ class WishlistControllerApi(
             .addPathSegment(uriComponent)
             .build()
             .encodedPathSegments[0]
-}
+}
\ No newline at end of file
diff --git a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/apis/WishlistProductControllerApi.kt b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/apis/WishlistProductControllerApi.kt
deleted file mode 100644
index 0f53e8e..0000000
--- a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/apis/WishlistProductControllerApi.kt
+++ /dev/null
@@ -1,264 +0,0 @@
-/**
- *
- * Please note:
- * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
- * Do not edit this file manually.
- *
- */
-
-@file:Suppress(
-    "ArrayInDataClass",
-    "EnumEntryName",
-    "RemoveRedundantQualifierName",
-    "UnusedImport", "unused"
-)
-
-package it.unical.informatica.ea.sefora_frontend.apis
-
-import java.io.IOException
-import okhttp3.OkHttpClient
-import okhttp3.HttpUrl
-
-import it.unical.informatica.ea.sefora_frontend.models.WishlistProductDto
-
-import com.squareup.moshi.Json
-
-import it.unical.informatica.ea.sefora_frontend.BuildConfig
-import it.unical.informatica.ea.sefora_frontend.infrastructure.ApiClient
-import it.unical.informatica.ea.sefora_frontend.infrastructure.ApiResponse
-import it.unical.informatica.ea.sefora_frontend.infrastructure.ClientException
-import it.unical.informatica.ea.sefora_frontend.infrastructure.ClientError
-import it.unical.informatica.ea.sefora_frontend.infrastructure.ServerException
-import it.unical.informatica.ea.sefora_frontend.infrastructure.ServerError
-import it.unical.informatica.ea.sefora_frontend.infrastructure.MultiValueMap
-import it.unical.informatica.ea.sefora_frontend.infrastructure.PartConfig
-import it.unical.informatica.ea.sefora_frontend.infrastructure.RequestConfig
-import it.unical.informatica.ea.sefora_frontend.infrastructure.RequestMethod
-import it.unical.informatica.ea.sefora_frontend.infrastructure.ResponseType
-import it.unical.informatica.ea.sefora_frontend.infrastructure.Success
-import it.unical.informatica.ea.sefora_frontend.infrastructure.toMultiValue
-import kotlinx.coroutines.Dispatchers
-import kotlinx.coroutines.withContext
-
-class WishlistProductControllerApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
-    companion object {
-        @JvmStatic
-        val defaultBasePath: String by lazy {
-            System.getProperties().getProperty(ApiClient.baseUrlKey, BuildConfig.SERVER_ADDRESS)
-
-        }
-    }
-
-    /**
-     * 
-     * 
-     * @param wishlistProductDto 
-     * @return WishlistProductDto
-     * @throws IllegalStateException If the request is not correctly configured
-     * @throws IOException Rethrows the OkHttp execute method exception
-     * @throws UnsupportedOperationException If the API returns an informational or redirection response
-     * @throws ClientException If the API returns a client error response
-     * @throws ServerException If the API returns a server error response
-     */
-    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
-    suspend fun createWishlistProduct(wishlistProductDto: WishlistProductDto) : WishlistProductDto= withContext(Dispatchers.IO) {
-        val localVarResponse = createWishlistProductWithHttpInfo(wishlistProductDto = wishlistProductDto)
-
-        return@withContext when (localVarResponse.responseType) {
-            ResponseType.Success -> (localVarResponse as Success<*>).data as WishlistProductDto
-            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
-            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
-            ResponseType.ClientError -> {
-                val localVarError = localVarResponse as ClientError<*>
-                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
-            }
-
-            ResponseType.ServerError -> {
-                val localVarError = localVarResponse as ServerError<*>
-                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
-            }
-        }
-    }
-
-    /**
-     * 
-     * 
-     * @param wishlistProductDto 
-     * @return ApiResponse<WishlistProductDto?>
-     * @throws IllegalStateException If the request is not correctly configured
-     * @throws IOException Rethrows the OkHttp execute method exception
-     */
-    @Throws(IllegalStateException::class, IOException::class)
-    fun createWishlistProductWithHttpInfo(wishlistProductDto: WishlistProductDto) : ApiResponse<WishlistProductDto?> {
-        val localVariableConfig = createWishlistProductRequestConfig(wishlistProductDto = wishlistProductDto)
-
-        return request<WishlistProductDto, WishlistProductDto>(
-            localVariableConfig
-        )
-    }
-
-    /**
-     * To obtain the request config of the operation createWishlistProduct
-     *
-     * @param wishlistProductDto 
-     * @return RequestConfig
-     */
-    fun createWishlistProductRequestConfig(wishlistProductDto: WishlistProductDto) : RequestConfig<WishlistProductDto> {
-        val localVariableBody = wishlistProductDto
-        val localVariableQuery: MultiValueMap = mutableMapOf()
-        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
-        localVariableHeaders["Content-Type"] = "application/json"
-        
-        return RequestConfig(
-            method = RequestMethod.POST,
-            path = "/api/wishlist-prodotti",
-            query = localVariableQuery,
-            headers = localVariableHeaders,
-            requiresAuthentication = true,
-            body = localVariableBody
-        )
-    }
-
-    /**
-     * 
-     * 
-     * @param id 
-     * @return void
-     * @throws IllegalStateException If the request is not correctly configured
-     * @throws IOException Rethrows the OkHttp execute method exception
-     * @throws UnsupportedOperationException If the API returns an informational or redirection response
-     * @throws ClientException If the API returns a client error response
-     * @throws ServerException If the API returns a server error response
-     */
-    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
-    suspend fun deleteWishlistProduct(id: kotlin.Long) = withContext(Dispatchers.IO){
-        val localVarResponse = deleteWishlistProductWithHttpInfo(id = id)
-
-        return@withContext when (localVarResponse.responseType) {
-            ResponseType.Success -> Unit
-            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
-            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
-            ResponseType.ClientError -> {
-                val localVarError = localVarResponse as ClientError<*>
-                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
-            }
-
-            ResponseType.ServerError -> {
-                val localVarError = localVarResponse as ServerError<*>
-                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
-            }
-        }
-    }
-
-    /**
-     * 
-     * 
-     * @param id 
-     * @return ApiResponse<Unit?>
-     * @throws IllegalStateException If the request is not correctly configured
-     * @throws IOException Rethrows the OkHttp execute method exception
-     */
-    @Throws(IllegalStateException::class, IOException::class)
-    fun deleteWishlistProductWithHttpInfo(id: kotlin.Long) : ApiResponse<Unit?> {
-        val localVariableConfig = deleteWishlistProductRequestConfig(id = id)
-
-        return request<Unit, Unit>(
-            localVariableConfig
-        )
-    }
-
-    /**
-     * To obtain the request config of the operation deleteWishlistProduct
-     *
-     * @param id 
-     * @return RequestConfig
-     */
-    fun deleteWishlistProductRequestConfig(id: kotlin.Long) : RequestConfig<Unit> {
-        val localVariableBody = null
-        val localVariableQuery: MultiValueMap = mutableMapOf()
-        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
-        
-        return RequestConfig(
-            method = RequestMethod.DELETE,
-            path = "/api/wishlist-prodotti/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
-            query = localVariableQuery,
-            headers = localVariableHeaders,
-            requiresAuthentication = true,
-            body = localVariableBody
-        )
-    }
-
-    /**
-     * 
-     * 
-     * @param id 
-     * @return kotlin.collections.List<WishlistProductDto>
-     * @throws IllegalStateException If the request is not correctly configured
-     * @throws IOException Rethrows the OkHttp execute method exception
-     * @throws UnsupportedOperationException If the API returns an informational or redirection response
-     * @throws ClientException If the API returns a client error response
-     * @throws ServerException If the API returns a server error response
-     */
-    @Suppress("UNCHECKED_CAST")
-    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
-    suspend fun getAllWishlistProductByWishlistId(id: kotlin.Long) : kotlin.collections.List<WishlistProductDto> = withContext(Dispatchers.IO){
-        val localVarResponse = getAllWishlistProductByWishlistIdWithHttpInfo(id = id)
-
-        return@withContext when (localVarResponse.responseType) {
-            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<WishlistProductDto>
-            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
-            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
-            ResponseType.ClientError -> {
-                val localVarError = localVarResponse as ClientError<*>
-                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
-            }
-
-            ResponseType.ServerError -> {
-                val localVarError = localVarResponse as ServerError<*>
-                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
-            }
-        }
-    }
-
-    /**
-     * 
-     * 
-     * @param id 
-     * @return ApiResponse<kotlin.collections.List<WishlistProductDto>?>
-     * @throws IllegalStateException If the request is not correctly configured
-     * @throws IOException Rethrows the OkHttp execute method exception
-     */
-    @Throws(IllegalStateException::class, IOException::class)
-    fun getAllWishlistProductByWishlistIdWithHttpInfo(id: kotlin.Long) : ApiResponse<kotlin.collections.List<WishlistProductDto>?> {
-        val localVariableConfig = getAllWishlistProductByWishlistIdRequestConfig(id = id)
-
-        return request<Unit, kotlin.collections.List<WishlistProductDto>>(
-            localVariableConfig
-        )
-    }
-
-    /**
-     * To obtain the request config of the operation getAllWishlistProductByWishlistId
-     *
-     * @param id 
-     * @return RequestConfig
-     */
-    fun getAllWishlistProductByWishlistIdRequestConfig(id: kotlin.Long) : RequestConfig<Unit> {
-        val localVariableBody = null
-        val localVariableQuery: MultiValueMap = mutableMapOf()
-        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
-        
-        return RequestConfig(
-            method = RequestMethod.GET,
-            path = "/api/wishlist-prodotti/wishlist/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
-            query = localVariableQuery,
-            headers = localVariableHeaders,
-            requiresAuthentication = true,
-            body = localVariableBody
-        )
-    }
-
-
-    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
-        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
-}
diff --git a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/auth/TokenManager.kt b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/auth/TokenManager.kt
index 26be869..62ce8ab 100644
--- a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/auth/TokenManager.kt
+++ b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/auth/TokenManager.kt
@@ -1,2 +1,286 @@
 package it.unical.informatica.ea.sefora_frontend.auth
 
+import android.content.Context
+import android.security.keystore.KeyProperties
+import android.security.keystore.KeyProtection
+import android.util.Log
+import androidx.datastore.core.DataStore
+import androidx.datastore.preferences.core.Preferences
+import androidx.datastore.preferences.core.edit
+import androidx.datastore.preferences.core.longPreferencesKey
+import androidx.datastore.preferences.core.stringPreferencesKey
+import androidx.datastore.preferences.preferencesDataStore
+import com.auth0.android.jwt.JWT
+import it.unical.informatica.ea.sefora_frontend.BuildConfig
+import it.unical.informatica.ea.sefora_frontend.apis.AccountControllerApi
+import kotlinx.coroutines.flow.Flow
+import kotlinx.coroutines.flow.first
+import kotlinx.coroutines.flow.firstOrNull
+import kotlinx.coroutines.flow.map
+import kotlinx.coroutines.runBlocking
+import okhttp3.OkHttpClient
+import it.unical.informatica.ea.sefora_frontend.infrastructure.Serializer
+import it.unical.informatica.ea.sefora_frontend.models.AccountDto
+import java.security.KeyStore
+import java.util.Base64
+import java.util.Date
+import javax.crypto.Cipher
+import javax.crypto.KeyGenerator
+import javax.crypto.SecretKey
+import javax.crypto.spec.GCMParameterSpec
+import javax.inject.Inject
+
+val Context.dataStore: DataStore<Preferences> by preferencesDataStore(name = "account_prefs")
+
+class TokenManager @Inject constructor(
+    private val context: Context
+) {
+
+    companion object {
+        private val ACCESS_TOKEN_KEY = stringPreferencesKey("access_token")
+        private val REFRESH_TOKEN_KEY = stringPreferencesKey("refresh_token")
+        private val USER = stringPreferencesKey("account")
+        private val EXPIRES_IN = longPreferencesKey("expires_in")
+        private const val KEYSTORE_ALIAS = "MyAppKeyAlias"
+        private const val ENCRYPTION_ALGORITHM = "AES/GCM/NoPadding"
+        private const val ENCRYPTION_KEY_SIZE = 256
+        private const val ENCRYPTION_IV_SIZE = 12
+
+        private val keyStore: KeyStore = KeyStore.getInstance("AndroidKeyStore").apply {
+            load(null)
+        }
+
+        init {
+            if (!keyStore.containsAlias(KEYSTORE_ALIAS)) {
+                val keyGenerator = KeyGenerator.getInstance("AES")
+                keyGenerator.init(ENCRYPTION_KEY_SIZE)
+                val secretKey = keyGenerator.generateKey()
+
+                // Define KeyProtection for the key
+                val keyProtection = KeyProtection.Builder(KeyProperties.PURPOSE_ENCRYPT or KeyProperties.PURPOSE_DECRYPT)
+                    .setBlockModes(KeyProperties.BLOCK_MODE_GCM)
+                    .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_NONE)
+                    .build()
+
+                // Store the key in the KeyStore with protection parameters
+                keyStore.setEntry(KEYSTORE_ALIAS, KeyStore.SecretKeyEntry(secretKey), keyProtection)
+            }
+        }
+    }
+
+    private val moshi = Serializer.moshi
+    private val accountAdapter = moshi.adapter(AccountDto::class.java)
+
+    // Save tokens with encryption
+    suspend fun saveTokens(
+        accessToken: String,
+        refreshToken: String,
+        account: AccountDto,
+        expires_in: Long
+    ) {
+        context.dataStore.edit { preferences ->
+            preferences[ACCESS_TOKEN_KEY] = encryptToken(accessToken)
+            preferences[REFRESH_TOKEN_KEY] = encryptToken(refreshToken)
+            preferences[USER] = accountAdapter.toJson(account)
+            preferences[EXPIRES_IN] = expires_in
+        }
+        logTokenActivity("Tokens saved successfully.")
+    }
+
+    // Retrieve account info
+    suspend fun getAccount(): AccountDto? {
+        val accountString = context.dataStore.data.map { preferences ->
+            preferences[USER]
+        }.firstOrNull()
+
+        return accountString?.let {
+            accountAdapter.fromJson(it)
+        }
+    }
+
+    // Clear tokens and logout
+    suspend fun logout() {
+        context.dataStore.edit { preferences ->
+            preferences.clear()
+        }
+        logTokenActivity("User logged out.")
+    }
+
+    // Access token flow
+    val accessTokenFlow: Flow<String?> = context.dataStore.data
+        .map { preferences ->
+            decryptToken(preferences[ACCESS_TOKEN_KEY])
+        }
+
+    // Refresh token flow
+    val refreshTokenFlow: Flow<String?> = context.dataStore.data
+        .map { preferences ->
+            decryptToken(preferences[REFRESH_TOKEN_KEY])
+        }
+
+    // Check login status flow
+    val isLoggedInFlow: Flow<Boolean> = context.dataStore.data
+        .map { preferences ->
+            val accessToken = decryptToken(preferences[ACCESS_TOKEN_KEY])
+            !accessToken.isNullOrEmpty()
+        }
+
+    // Check if the access token is expired
+    fun isAccessTokenExpired(): Boolean {
+        val accessToken = getAccessToken()
+        if (accessToken.isNullOrEmpty()) {
+            return true
+        }
+
+        return try {
+            val jwt = JWT(accessToken)
+            val expiresAt = jwt.expiresAt
+            expiresAt != null && expiresAt.before(Date())
+        } catch (e: Exception) {
+            e.printStackTrace()
+            true
+        }
+    }
+
+    // Get access token (decrypted)
+    fun getAccessToken(): String? {
+        var token: String?
+        runBlocking {
+            val preferences = context.dataStore.data.first()
+            token = decryptToken(preferences[ACCESS_TOKEN_KEY])
+        }
+        return token
+    }
+
+    // Get refresh token (decrypted)
+    fun getRefreshToken(): String? {
+        var token: String?
+        runBlocking {
+            val preferences = context.dataStore.data.first()
+            token = decryptToken(preferences[REFRESH_TOKEN_KEY])
+        }
+        return token
+    }
+
+    // Refresh access token if expired
+    suspend fun refreshAccessTokenIfNeeded(): Boolean {
+        if (isAccessTokenExpired()) {
+            val refreshToken = getRefreshToken()
+            if (!refreshToken.isNullOrEmpty()) {
+                try {
+                    // Call API to refresh access token
+                    val apiService: AccountControllerApi = AccountControllerApi( // Inject AccountControllerApi
+                        basePath = BuildConfig.SERVER_ADDRESS,
+                        client = OkHttpClient.Builder().build(),
+                    )
+                    val newTokens = apiService.refreshToken()
+                    saveTokens(
+                        newTokens.accessToken,
+                        newTokens.refreshToken,
+                        newTokens.account,
+                        newTokens.expiresIn
+                    )
+                    logTokenActivity("Access token refreshed successfully.")
+                    return true
+                } catch (e: Exception) {
+                    e.printStackTrace()
+                    logTokenActivity("Failed to refresh access token.")
+                }
+            }
+        }
+        return false
+    }
+
+    // Encrypt token
+    private fun encryptToken(token: String): String {
+        val cipher = Cipher.getInstance(ENCRYPTION_ALGORITHM)
+        val secretKey = keyStore.getKey(KEYSTORE_ALIAS, null) as SecretKey
+        cipher.init(Cipher.ENCRYPT_MODE, secretKey)
+        val iv = cipher.iv
+        val encryptedData = cipher.doFinal(token.toByteArray(Charsets.UTF_8))
+        val combinedData = iv + encryptedData
+        return Base64.getEncoder().encodeToString(combinedData)
+    }
+
+    // Decrypt token
+    private fun decryptToken(encryptedToken: String?): String? {
+        if (encryptedToken == null) return null
+        val cipher = Cipher.getInstance(ENCRYPTION_ALGORITHM)
+        val secretKey = keyStore.getKey(KEYSTORE_ALIAS, null) as SecretKey
+        val decodedData = Base64.getDecoder().decode(encryptedToken)
+        val iv = decodedData.sliceArray(0 until ENCRYPTION_IV_SIZE)
+        val encryptedData = decodedData.sliceArray(ENCRYPTION_IV_SIZE until decodedData.size)
+        val spec = GCMParameterSpec(128, iv)
+        cipher.init(Cipher.DECRYPT_MODE, secretKey, spec)
+        val decryptedData = cipher.doFinal(encryptedData)
+        return String(decryptedData, Charsets.UTF_8)
+    }
+
+    // Validate token structure
+    fun isTokenValid(token: String): Boolean {
+        return try {
+            val jwt = JWT(token)
+            !jwt.isExpired(10) // Checks if expired with 10 seconds of leeway
+        } catch (e: Exception) {
+            e.printStackTrace()
+            false
+        }
+    }
+
+    // Log token activities
+    private fun logTokenActivity(message: String) {
+        Log.d("TokenManager", message)
+    }
+
+    // Get user roles from token
+    fun getUserRoles(): List<String>? {
+        val accessToken = getAccessToken()
+        return if (!accessToken.isNullOrEmpty()) {
+            val jwt = JWT(accessToken)
+            jwt.getClaim("roles").asList(String::class.java)
+        } else {
+            null
+        }
+    }
+
+    // Check if user has a specific role
+    fun hasRole(role: String): Boolean {
+        val roles = getUserRoles()
+        return roles?.contains(role) ?: false
+    }
+
+    // New Method: Get token expiration date
+    fun getTokenExpirationDate(): Date? {
+        val accessToken = getAccessToken()
+        return accessToken?.let {
+            val jwt = JWT(it)
+            jwt.expiresAt
+        }
+    }
+
+    // New Method: Force logout if token is invalid
+    suspend fun forceLogoutIfInvalid() {
+        if (!isTokenValid(getAccessToken() ?: "")) {
+            logout()
+            logTokenActivity("Forced logout due to invalid token.")
+        }
+    }
+
+    // New Method: Get time left until token expires (in milliseconds)
+    fun getTimeUntilTokenExpires(): Long {
+        val expirationDate = getTokenExpirationDate()
+        return expirationDate?.time?.minus(System.currentTimeMillis()) ?: 0
+    }
+
+    // Clear only tokens (access token and refresh token)
+    suspend fun clearTokens() {
+        context.dataStore.edit { preferences ->
+            preferences.remove(ACCESS_TOKEN_KEY)
+            preferences.remove(REFRESH_TOKEN_KEY)
+            preferences.remove(EXPIRES_IN)
+            preferences.remove(USER)
+        }
+        logTokenActivity("Tokens cleared successfully.")
+    }
+
+}
diff --git a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/infrastructure/ApiAbstractions.kt b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/infrastructure/ApiAbstractions.kt
index 2af4889..4525409 100644
--- a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/infrastructure/ApiAbstractions.kt
+++ b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/infrastructure/ApiAbstractions.kt
@@ -1,4 +1,4 @@
-package org.openapitools.client.infrastructure
+package it.unical.informatica.ea.sefora_frontend.infrastructure
 
 typealias MultiValueMap = MutableMap<String, List<String>>
 
diff --git a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/infrastructure/ApiClient.kt b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/infrastructure/ApiClient.kt
index 0afc6a4..d65dfdf 100644
--- a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/infrastructure/ApiClient.kt
+++ b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/infrastructure/ApiClient.kt
@@ -1,5 +1,7 @@
-package org.openapitools.client.infrastructure
+package it.unical.informatica.ea.sefora_frontend.infrastructure
 
+import android.annotation.SuppressLint
+import com.squareup.moshi.JsonReader
 import com.squareup.moshi.adapter
 import okhttp3.FormBody
 import okhttp3.Headers.Companion.toHeaders
@@ -21,6 +23,9 @@ import java.time.OffsetDateTime
 import java.time.OffsetTime
 import java.util.Locale
 import java.util.regex.Pattern
+import javax.inject.Inject
+
+
 
 val EMPTY_REQUEST: RequestBody = ByteArray(0).toRequestBody()
 
@@ -43,7 +48,7 @@ open class ApiClient(
         var username: String? = null
         var password: String? = null
         var accessToken: String? = null
-        const val baseUrlKey = "org.openapitools.client.baseUrl"
+        const val baseUrlKey = "it.unical.informatica.ea.sefora_frontend.baseUrl"
 
         @JvmStatic
         val defaultClient: OkHttpClient by lazy {
@@ -65,6 +70,11 @@ open class ApiClient(
         return contentType ?: "application/octet-stream"
     }
 
+    // Set access token
+    fun setToken(token: String?) {
+        accessToken = token ?: ""
+    }
+
     protected inline fun <reified T> requestBody(
         content: T,
         mediaType: String?,
@@ -191,12 +201,16 @@ open class ApiClient(
         }
 
         return when {
+            response.body?.contentLength() == 0L -> {
+                // Handle cases where the response body is empty or null
+                // This covers 204 No Content, 401, 403, or any other status with an empty body
+                null // Or return a suitable default value for your application
+            }
             mediaType == null || (mediaType.startsWith("application/") && mediaType.endsWith("json")) -> {
-                val bodyContent = body.string()
-                if (bodyContent.isEmpty()) {
-                    return null
-                }
-                Serializer.moshi.adapter<T>().fromJson(bodyContent)
+                val source = body.source() // Get BufferedSource directly from the response body
+                val jsonReader = JsonReader.of(source)
+                jsonReader.isLenient = true // Set lenient mode
+                Serializer.moshi.adapter<T>().fromJson(jsonReader)
             }
             mediaType == OctetMediaType -> body.bytes() as? T
             else -> throw UnsupportedOperationException("responseBody currently only supports JSON body.")
@@ -328,4 +342,10 @@ open class ApiClient(
             .toJson(value)
             .replace("\"", "")
     }
+
+    @SuppressLint("NotConstructor")
+    @Inject
+    fun ApiClient() {
+
+    }
 }
diff --git a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/infrastructure/ApiResponse.kt b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/infrastructure/ApiResponse.kt
index 4b1677d..1f24ed0 100644
--- a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/infrastructure/ApiResponse.kt
+++ b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/infrastructure/ApiResponse.kt
@@ -1,4 +1,4 @@
-package org.openapitools.client.infrastructure
+package it.unical.informatica.ea.sefora_frontend.infrastructure
 
 enum class ResponseType {
     Success,
diff --git a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/infrastructure/BigDecimalAdapter.kt b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/infrastructure/BigDecimalAdapter.kt
index 6531626..8a1da64 100644
--- a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/infrastructure/BigDecimalAdapter.kt
+++ b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/infrastructure/BigDecimalAdapter.kt
@@ -1,4 +1,4 @@
-package org.openapitools.client.infrastructure
+package it.unical.informatica.ea.sefora_frontend.infrastructure
 
 import com.squareup.moshi.FromJson
 import com.squareup.moshi.ToJson
diff --git a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/infrastructure/BigIntegerAdapter.kt b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/infrastructure/BigIntegerAdapter.kt
index 5cc9ead..c6122ed 100644
--- a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/infrastructure/BigIntegerAdapter.kt
+++ b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/infrastructure/BigIntegerAdapter.kt
@@ -1,4 +1,4 @@
-package org.openapitools.client.infrastructure
+package it.unical.informatica.ea.sefora_frontend.infrastructure
 
 import com.squareup.moshi.FromJson
 import com.squareup.moshi.ToJson
diff --git a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/infrastructure/ByteArrayAdapter.kt b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/infrastructure/ByteArrayAdapter.kt
index ff5e2a8..64148b0 100644
--- a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/infrastructure/ByteArrayAdapter.kt
+++ b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/infrastructure/ByteArrayAdapter.kt
@@ -1,4 +1,4 @@
-package org.openapitools.client.infrastructure
+package it.unical.informatica.ea.sefora_frontend.infrastructure
 
 import com.squareup.moshi.FromJson
 import com.squareup.moshi.ToJson
diff --git a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/infrastructure/Errors.kt b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/infrastructure/Errors.kt
index 3fe4795..8fd53de 100644
--- a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/infrastructure/Errors.kt
+++ b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/infrastructure/Errors.kt
@@ -1,6 +1,6 @@
 @file:Suppress("unused")
 
-package org.openapitools.client.infrastructure
+package it.unical.informatica.ea.sefora_frontend.infrastructure
 
 import java.lang.RuntimeException
 
diff --git a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/infrastructure/LocalDateAdapter.kt b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/infrastructure/LocalDateAdapter.kt
index 6a839be..b1e5864 100644
--- a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/infrastructure/LocalDateAdapter.kt
+++ b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/infrastructure/LocalDateAdapter.kt
@@ -1,4 +1,4 @@
-package org.openapitools.client.infrastructure
+package it.unical.informatica.ea.sefora_frontend.infrastructure
 
 import com.squareup.moshi.FromJson
 import com.squareup.moshi.ToJson
diff --git a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/infrastructure/LocalDateTimeAdapter.kt b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/infrastructure/LocalDateTimeAdapter.kt
index 6bf9508..fd79520 100644
--- a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/infrastructure/LocalDateTimeAdapter.kt
+++ b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/infrastructure/LocalDateTimeAdapter.kt
@@ -1,4 +1,4 @@
-package org.openapitools.client.infrastructure
+package it.unical.informatica.ea.sefora_frontend.infrastructure
 
 import com.squareup.moshi.FromJson
 import com.squareup.moshi.ToJson
diff --git a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/infrastructure/OffsetDateTimeAdapter.kt b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/infrastructure/OffsetDateTimeAdapter.kt
index 5e19f26..e1ab37a 100644
--- a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/infrastructure/OffsetDateTimeAdapter.kt
+++ b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/infrastructure/OffsetDateTimeAdapter.kt
@@ -1,4 +1,4 @@
-package org.openapitools.client.infrastructure
+package it.unical.informatica.ea.sefora_frontend.infrastructure
 
 import com.squareup.moshi.FromJson
 import com.squareup.moshi.ToJson
diff --git a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/infrastructure/PartConfig.kt b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/infrastructure/PartConfig.kt
index 11033a2..e67b0d9 100644
--- a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/infrastructure/PartConfig.kt
+++ b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/infrastructure/PartConfig.kt
@@ -1,4 +1,4 @@
-package org.openapitools.client.infrastructure
+package it.unical.informatica.ea.sefora_frontend.infrastructure
 
 /**
  * Defines a config object for a given part of a multi-part request.
diff --git a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/infrastructure/RequestConfig.kt b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/infrastructure/RequestConfig.kt
index d841e2f..1b103f3 100644
--- a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/infrastructure/RequestConfig.kt
+++ b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/infrastructure/RequestConfig.kt
@@ -1,4 +1,4 @@
-package org.openapitools.client.infrastructure
+package it.unical.informatica.ea.sefora_frontend.infrastructure
 
 /**
  * Defines a config object for a given request.
diff --git a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/infrastructure/RequestMethod.kt b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/infrastructure/RequestMethod.kt
index 813e103..532f0e0 100644
--- a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/infrastructure/RequestMethod.kt
+++ b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/infrastructure/RequestMethod.kt
@@ -1,4 +1,4 @@
-package org.openapitools.client.infrastructure
+package it.unical.informatica.ea.sefora_frontend.infrastructure
 
 /**
  * Provides enumerated HTTP verbs
diff --git a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/infrastructure/ResponseExtensions.kt b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/infrastructure/ResponseExtensions.kt
index c45b7c3..854502a 100644
--- a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/infrastructure/ResponseExtensions.kt
+++ b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/infrastructure/ResponseExtensions.kt
@@ -1,4 +1,4 @@
-package org.openapitools.client.infrastructure
+package it.unical.informatica.ea.sefora_frontend.infrastructure
 
 import okhttp3.Response
 
diff --git a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/infrastructure/Serializer.kt b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/infrastructure/Serializer.kt
index ee8f77e..4e91fb1 100644
--- a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/infrastructure/Serializer.kt
+++ b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/infrastructure/Serializer.kt
@@ -1,4 +1,4 @@
-package org.openapitools.client.infrastructure
+package it.unical.informatica.ea.sefora_frontend.infrastructure
 
 import com.squareup.moshi.Moshi
 import com.squareup.moshi.kotlin.reflect.KotlinJsonAdapterFactory
@@ -17,6 +17,7 @@ object Serializer {
             .add(KotlinJsonAdapterFactory())
             .add(BigDecimalAdapter())
             .add(BigIntegerAdapter())
+            .add(BitmapConverter())
 
     @JvmStatic
     val moshi: Moshi by lazy {
diff --git a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/infrastructure/URIAdapter.kt b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/infrastructure/URIAdapter.kt
index 9275227..6bcd216 100644
--- a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/infrastructure/URIAdapter.kt
+++ b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/infrastructure/URIAdapter.kt
@@ -1,4 +1,4 @@
-package org.openapitools.client.infrastructure
+package it.unical.informatica.ea.sefora_frontend.infrastructure
 
 import com.squareup.moshi.FromJson
 import com.squareup.moshi.ToJson
diff --git a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/infrastructure/UUIDAdapter.kt b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/infrastructure/UUIDAdapter.kt
index 7ccf7dc..edd51e7 100644
--- a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/infrastructure/UUIDAdapter.kt
+++ b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/infrastructure/UUIDAdapter.kt
@@ -1,4 +1,4 @@
-package org.openapitools.client.infrastructure
+package it.unical.informatica.ea.sefora_frontend.infrastructure
 
 import com.squareup.moshi.FromJson
 import com.squareup.moshi.ToJson
diff --git a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/models/AccountDto.kt b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/models/AccountDto.kt
index 3a4479b..b29d82a 100644
--- a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/models/AccountDto.kt
+++ b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/models/AccountDto.kt
@@ -13,10 +13,13 @@
     "UnusedImport",
 )
 
-package org.openapitools.client.models
+package it.unical.informatica.ea.sefora_frontend.models
 
+import android.graphics.Bitmap
 import com.squareup.moshi.Json
 import com.squareup.moshi.JsonClass
+import kotlinx.serialization.Serializable
+import java.util.regex.Pattern
 
 /**
  *
@@ -35,27 +38,28 @@ import com.squareup.moshi.JsonClass
  * @param productsDto
  */
 
-data class AccountDto(
+@JsonClass(generateAdapter = true)
+data class AccountDto (
     @Json(name = "email")
-    val email: kotlin.String,
+    var email: kotlin.String,
     @Json(name = "role")
-    val role: AccountDto.Role,
+    var role: AccountDto.Role,
     @Json(name = "banned")
-    val banned: kotlin.Boolean,
+    var banned: kotlin.Boolean,
     @Json(name = "profileImage")
-    val profileImage: kotlin.String,
+    var profileImage: Bitmap? = null,
     @Json(name = "id")
     val id: kotlin.Long? = null,
     @Json(name = "firstname")
-    val firstname: kotlin.String? = null,
+    var firstname: kotlin.String,
     @Json(name = "lastname")
-    val lastname: kotlin.String? = null,
+    var lastname: kotlin.String,
     @Json(name = "phone")
-    val phone: kotlin.String? = null,
+    var phone: kotlin.String?,
     @Json(name = "cartId")
     val cartId: kotlin.Long? = null,
     @Json(name = "wishlistsDto")
-    val wishlistsDto: kotlin.collections.List<WishlistDto>? = null,
+    val wishlistsDto: WishlistDto? = null,
     @Json(name = "purchaseDto")
     val purchaseDto: kotlin.collections.List<PurchaseDto>? = null,
     @Json(name = "productsDto")
@@ -76,4 +80,38 @@ data class AccountDto(
         @Json(name = "ADMIN")
         ADMIN("ADMIN"),
     }
+
+    companion object {
+        fun validateFirstName(firstName: String): Boolean {
+            return firstName.length in 2..30
+        }
+
+        fun validateLastName(lastName: String): Boolean {
+            return lastName.length in 2..30
+        }
+
+        fun validateEmail(email: String): Boolean {
+            val emailRegex = Pattern.compile(
+                "[a-zA-Z0-9+._%\\-]{1,256}" +
+                        "@" +
+                        "[a-zA-Z0-9][a-zA-Z0-9\\-]{0,64}" +
+                        "(" +
+                        "\\." +
+                        "[a-zA-Z0-9][a-zA-Z0-9\\-]{0,25}" +
+                        ")+"
+            )
+            return emailRegex.matcher(email).matches()
+        }
+
+        fun validatePhone(phone: String): Boolean {
+            return android.util.Patterns.PHONE.matcher(phone).matches()
+        }
+
+        fun validatePassword(password: String): Boolean {
+            val passwordRegex = Pattern.compile(
+                "^(?=.*[0-9])(?=.*[a-z])(?=.*[A-Z])(?=.*[@#\$%^&+=!])(?=\\S+\$).{8,}\$"
+            )
+            return passwordRegex.matcher(password).matches()
+        }
+    }
 }
diff --git a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/models/AccountShortDto.kt b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/models/AccountShortDto.kt
index 4c70549..a9a4759 100644
--- a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/models/AccountShortDto.kt
+++ b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/models/AccountShortDto.kt
@@ -10,12 +10,15 @@
     "ArrayInDataClass",
     "EnumEntryName",
     "RemoveRedundantQualifierName",
-    "UnusedImport",
+    "UnusedImport"
 )
 
-package org.openapitools.client.models
+package it.unical.informatica.ea.sefora_frontend.models
 
+
+import android.graphics.Bitmap
 import com.squareup.moshi.Json
+import com.squareup.moshi.JsonClass
 
 /**
  *
@@ -23,13 +26,43 @@ import com.squareup.moshi.Json
  * @param id
  * @param email
  * @param firstname
+ * @param role
+ * @param isBanned
+ * @param profileImage
  */
 
-data class AccountShortDto(
+@JsonClass(generateAdapter = true)
+data class AccountShortDto (
+
     @Json(name = "id")
     val id: kotlin.Long,
+
     @Json(name = "email")
     val email: kotlin.String,
+
     @Json(name = "firstname")
     val firstname: kotlin.String,
-)
+
+    @Json(name = "role")
+    val role: Role? = null,
+
+    @Json(name = "isBanned")
+    val isBanned: kotlin.Boolean? = null,
+
+    @Json(name = "profileImage")
+    val profileImage: Bitmap? = null
+
+) {
+
+    /**
+     *
+     *
+     * Values: USER,ADMIN
+     */
+    @JsonClass(generateAdapter = false)
+    enum class Role(val value: kotlin.String) {
+        @Json(name = "USER") USER("USER"),
+        @Json(name = "ADMIN") ADMIN("ADMIN");
+    }
+
+}
diff --git a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/models/AuthenticationRequest.kt b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/models/AuthenticationRequest.kt
index 198ad36..13c518d 100644
--- a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/models/AuthenticationRequest.kt
+++ b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/models/AuthenticationRequest.kt
@@ -13,7 +13,7 @@
     "UnusedImport",
 )
 
-package org.openapitools.client.models
+package it.unical.informatica.ea.sefora_frontend.models
 
 import com.squareup.moshi.Json
 
@@ -29,4 +29,6 @@ data class AuthenticationRequest(
     val password: kotlin.String? = null,
     @Json(name = "email")
     val email: kotlin.String? = null,
+    @Json(name = "idToken")
+    val idToken: kotlin.String? = null,
 )
diff --git a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/models/AuthenticationResponse.kt b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/models/AuthenticationResponse.kt
index 6d7508e..2e22e4c 100644
--- a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/models/AuthenticationResponse.kt
+++ b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/models/AuthenticationResponse.kt
@@ -13,7 +13,7 @@
     "UnusedImport",
 )
 
-package org.openapitools.client.models
+package it.unical.informatica.ea.sefora_frontend.models
 
 import com.squareup.moshi.Json
 
@@ -28,11 +28,11 @@ import com.squareup.moshi.Json
 
 data class AuthenticationResponse(
     @Json(name = "access_token")
-    val accessToken: kotlin.String? = null,
+    val accessToken: kotlin.String,
     @Json(name = "refresh_token")
-    val refreshToken: kotlin.String? = null,
+    val refreshToken: kotlin.String,
     @Json(name = "user")
-    val account: AccountDto? = null,
+    val account: AccountDto,
     @Json(name = "expires_in")
-    val expiresIn: kotlin.Long? = null,
+    val expiresIn: kotlin.Long
 )
diff --git a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/models/CartDto.kt b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/models/CartDto.kt
index 9b20a48..69864c7 100644
--- a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/models/CartDto.kt
+++ b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/models/CartDto.kt
@@ -13,7 +13,7 @@
     "UnusedImport",
 )
 
-package org.openapitools.client.models
+package it.unical.informatica.ea.sefora_frontend.models
 
 import com.squareup.moshi.Json
 
diff --git a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/models/ChangePasswordRequest.kt b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/models/ChangePasswordRequest.kt
index e29d570..3b89c1d 100644
--- a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/models/ChangePasswordRequest.kt
+++ b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/models/ChangePasswordRequest.kt
@@ -13,7 +13,7 @@
     "UnusedImport",
 )
 
-package org.openapitools.client.models
+package it.unical.informatica.ea.sefora_frontend.models
 
 import com.squareup.moshi.Json
 
diff --git a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/models/ProductDto.kt b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/models/ProductDto.kt
index 43517cf..066fa84 100644
--- a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/models/ProductDto.kt
+++ b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/models/ProductDto.kt
@@ -13,7 +13,7 @@
     "UnusedImport",
 )
 
-package org.openapitools.client.models
+package it.unical.informatica.ea.sefora_frontend.models
 
 import android.graphics.Bitmap
 import com.squareup.moshi.Json
@@ -30,7 +30,7 @@ import com.squareup.moshi.JsonClass
  * @param price
  * @param imageProduct
  */
-
+@JsonClass(generateAdapter = true)
 data class ProductDto(
     @Json(name = "name")
     val name: kotlin.String,
diff --git a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/models/ProductShortDto.kt b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/models/ProductShortDto.kt
index cb970b1..e2afb11 100644
--- a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/models/ProductShortDto.kt
+++ b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/models/ProductShortDto.kt
@@ -13,7 +13,7 @@
     "UnusedImport",
 )
 
-package org.openapitools.client.models
+package it.unical.informatica.ea.sefora_frontend.models
 
 import com.squareup.moshi.Json
 
diff --git a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/models/PurchaseDto.kt b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/models/PurchaseDto.kt
index 9f8ea9f..2ffc2aa 100644
--- a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/models/PurchaseDto.kt
+++ b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/models/PurchaseDto.kt
@@ -13,7 +13,7 @@
     "UnusedImport",
 )
 
-package org.openapitools.client.models
+package it.unical.informatica.ea.sefora_frontend.models
 
 import com.squareup.moshi.Json
 
diff --git a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/models/RegisterRequest.kt b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/models/RegisterRequest.kt
index cc7d31e..348b2bb 100644
--- a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/models/RegisterRequest.kt
+++ b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/models/RegisterRequest.kt
@@ -13,7 +13,7 @@
     "UnusedImport",
 )
 
-package org.openapitools.client.models
+package it.unical.informatica.ea.sefora_frontend.models
 
 import com.squareup.moshi.Json
 import com.squareup.moshi.JsonClass
diff --git a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/models/WishlistDto.kt b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/models/WishlistDto.kt
index 37e1a5e..f9880fb 100644
--- a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/models/WishlistDto.kt
+++ b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/models/WishlistDto.kt
@@ -13,7 +13,7 @@
     "UnusedImport",
 )
 
-package org.openapitools.client.models
+package it.unical.informatica.ea.sefora_frontend.models
 
 import com.squareup.moshi.Json
 import com.squareup.moshi.JsonClass
@@ -21,23 +21,24 @@ import com.squareup.moshi.JsonClass
 /**
  *
  *
- * @param userWishlistId
- * @param products
+ * @param account
  * @param type
  * @param id
+ * @param products
  * @param name
  * @param sharedWithUsers
  */
 
+@JsonClass(generateAdapter = true)
 data class WishlistDto(
-    @Json(name = "userWishlistId")
-    val userWishlistId: kotlin.Long,
-    @Json(name = "products")
-    val products: kotlin.collections.List<ProductShortDto>,
+    @Json(name = "account")
+    val account: AccountShortDto,
     @Json(name = "type")
     val type: WishlistDto.Type,
     @Json(name = "id")
     val id: kotlin.Long? = null,
+    @Json(name = "products")
+    val products: kotlin.collections.List<ProductDto>? = null,
     @Json(name = "name")
     val name: kotlin.String? = null,
     @Json(name = "sharedWithUsers")
@@ -61,4 +62,4 @@ data class WishlistDto(
         @Json(name = "SHARED")
         SHARED("SHARED"),
     }
-}
+}
\ No newline at end of file
diff --git a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/ui/theme/Color.kt b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/ui/theme/Color.kt
index 0c35ecf..de39d09 100644
--- a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/ui/theme/Color.kt
+++ b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/ui/theme/Color.kt
@@ -2,10 +2,11 @@ package it.unical.informatica.ea.sefora_frontend.ui.theme
 
 import androidx.compose.ui.graphics.Color
 
-val Purple80 = Color(0xFFD0BCFF)
-val PurpleGrey80 = Color(0xFFCCC2DC)
-val Pink80 = Color(0xFFEFB8C8)
+// Navy blue and complementary colors
+val NavyBlue80 = Color(0xFF001f4d) // A darker shade of navy blue
+val BlueGrey80 = Color(0xFF4d6082) // A greyish blue
+val LightBlue80 = Color(0xFF99b3cc) // A lighter shade of blue
 
-val Purple40 = Color(0xFF6650a4)
-val PurpleGrey40 = Color(0xFF625b71)
-val Pink40 = Color(0xFF7D5260)
\ No newline at end of file
+val NavyBlue40 = Color(0xFF003366) // A mid-tone navy blue
+val BlueGrey40 = Color(0xFF667d99) // A medium greyish blue
+val LightBlue40 = Color(0xFFb3c6e0) // A very light blue
\ No newline at end of file
diff --git a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/ui/theme/Theme.kt b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/ui/theme/Theme.kt
index a0e93bf..0d29738 100644
--- a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/ui/theme/Theme.kt
+++ b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/ui/theme/Theme.kt
@@ -1,6 +1,5 @@
 package it.unical.informatica.ea.sefora_frontend.ui.theme
 
-import android.app.Activity
 import android.os.Build
 import androidx.compose.foundation.isSystemInDarkTheme
 import androidx.compose.material3.MaterialTheme
@@ -12,15 +11,15 @@ import androidx.compose.runtime.Composable
 import androidx.compose.ui.platform.LocalContext
 
 private val DarkColorScheme = darkColorScheme(
-    primary = Purple80,
-    secondary = PurpleGrey80,
-    tertiary = Pink80
+    primary = NavyBlue80,
+    secondary = BlueGrey80,
+    tertiary = LightBlue80
 )
 
 private val LightColorScheme = lightColorScheme(
-    primary = Purple40,
-    secondary = PurpleGrey40,
-    tertiary = Pink40
+    primary = NavyBlue40,
+    secondary = BlueGrey40,
+    tertiary = LightBlue40
 
     /* Other default colors to override
     background = Color(0xFFFFFBFE),
diff --git a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/viewmodel/AccountViewModel.kt b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/viewmodel/AccountViewModel.kt
index ac90c10..6ee7545 100644
--- a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/viewmodel/AccountViewModel.kt
+++ b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/viewmodel/AccountViewModel.kt
@@ -1,4 +1,286 @@
 package it.unical.informatica.ea.sefora_frontend.viewmodel
 
-class AccountViewModel {
+import android.graphics.Bitmap
+import android.util.Log
+import androidx.compose.runtime.getValue
+import androidx.compose.runtime.mutableStateOf
+import androidx.compose.runtime.setValue
+import androidx.lifecycle.ViewModel
+import androidx.lifecycle.viewModelScope
+import com.squareup.moshi.JsonEncodingException
+import dagger.hilt.android.lifecycle.HiltViewModel
+import it.unical.informatica.ea.sefora_frontend.apis.AccountControllerApi
+import it.unical.informatica.ea.sefora_frontend.apis.WishlistControllerApi
+import it.unical.informatica.ea.sefora_frontend.auth.TokenManager
+import it.unical.informatica.ea.sefora_frontend.infrastructure.ClientException
+import it.unical.informatica.ea.sefora_frontend.infrastructure.ServerException
+import it.unical.informatica.ea.sefora_frontend.models.AccountDto
+import it.unical.informatica.ea.sefora_frontend.models.AccountShortDto
+import it.unical.informatica.ea.sefora_frontend.models.ChangePasswordRequest
+import kotlinx.coroutines.flow.MutableStateFlow
+import kotlinx.coroutines.flow.StateFlow
+import kotlinx.coroutines.flow.asStateFlow
+import kotlinx.coroutines.launch
+import java.io.IOException
+import javax.inject.Inject
+
+data class AccountState(
+    var firstName: String = "",
+    var lastName: String = "",
+    var email: String = "",
+    var oldPassword: String = "",
+    var newPassword: String = "",
+    var confirmPassword: String = "",
+    var phone: String = "",
+    val role : AccountDto.Role = AccountDto.Role.USER,
+    val profilePic : Bitmap? = null,
+)
+
+data class AdminState(
+    val accounts: List<AccountShortDto> = emptyList(),
+)
+
+@HiltViewModel
+class AccountViewModel @Inject constructor(
+    val tokenManager: TokenManager,
+): ViewModel() {
+    private val accountApi = AccountControllerApi()
+    private val wishlistApi = WishlistControllerApi()
+    private val _accountUpd = MutableStateFlow(AccountState())
+    val accountState: StateFlow<AccountState> = _accountUpd.asStateFlow()
+    private val _account = MutableStateFlow<AccountDto?>(null)
+    private val _adminState = MutableStateFlow(AdminState())
+    val adminState: StateFlow<AdminState> = _adminState.asStateFlow()
+    val account: StateFlow<AccountDto?> = _account.asStateFlow()
+    val isLoading = mutableStateOf(false)
+
+    var firstNameError by mutableStateOf<String?>(null)
+    var lastNameError by mutableStateOf<String?>(null)
+    var emailError by mutableStateOf<String?>(null)
+    var passwordError by mutableStateOf<String?>(null)
+    var phoneError by mutableStateOf<String?>(null)
+    var profilePicError by mutableStateOf<String?>(null)
+    var oldPasswordError by mutableStateOf<String?>(null)
+    var newPasswordError by mutableStateOf<String?>(null)
+    var confirmPasswordError by mutableStateOf<String?>(null)
+    var error by mutableStateOf<String?>(null)
+
+    fun onFirstNameChanged(firstName: String) {
+        _accountUpd.value = _accountUpd.value.copy(firstName = firstName)
+        firstNameError = if(!AccountDto.validateFirstName(_accountUpd.value.firstName)) "First name cannot be empty" else null
+    }
+
+    fun onLastNameChanged(lastName: String) {
+        _accountUpd.value = _accountUpd.value.copy(lastName = lastName)
+        lastNameError = if(!AccountDto.validateLastName(_accountUpd.value.lastName)) "Last name cannot be empty" else null
+    }
+
+    fun onEmailChanged(email: String) {
+        _accountUpd.value = _accountUpd.value.copy(email = email)
+        emailError = if(!AccountDto.validateEmail(_accountUpd.value.email)) "Invalid email" else null
+    }
+
+    fun onPhoneChanged(phone: String) {
+        _accountUpd.value = _accountUpd.value.copy(phone = phone)
+        phoneError = if(!AccountDto.validatePhone(_accountUpd.value.phone)) "Invalid phone number" else null
+    }
+
+    fun onProfilePicChanged(profilePic: Bitmap?) {
+        _accountUpd.value = _accountUpd.value.copy(profilePic = profilePic)
+    }
+
+    fun onOldPasswordChanged(oldPassword: String) {
+        _accountUpd.value = _accountUpd.value.copy(oldPassword = oldPassword)
+        oldPasswordError = if(!AccountDto.validatePassword(_accountUpd.value.oldPassword)) "Password must be at least 8 characters long" else null
+    }
+
+    fun onNewPasswordChanged(newPassword: String) {
+        _accountUpd.value = _accountUpd.value.copy(newPassword = newPassword)
+        newPasswordError = if(!AccountDto.validatePassword(_accountUpd.value.newPassword)) "Password must be at least 8 characters long" else null
+    }
+
+    fun onConfirmPasswordChanged(confirmPassword: String) {
+        _accountUpd.value = _accountUpd.value.copy(confirmPassword = confirmPassword)
+        confirmPasswordError = if(_accountUpd.value.newPassword != _accountUpd.value.confirmPassword) "Passwords do not match" else null
+    }
+
+    // TODO implementare logica del token e del login
+    fun updateAccount(
+        id: Long,
+        role: AccountDto.Role,
+        banned: Boolean,
+        image: Bitmap?,
+        onSuccess: () -> Unit
+    ) {
+        isLoading.value = true
+        viewModelScope.launch {
+            try {
+                val account = AccountDto(
+                    id = id,
+                    firstname = _accountUpd.value.firstName,
+                    lastname = _accountUpd.value.lastName,
+                    email = _accountUpd.value.email,
+                    phone = _accountUpd.value.phone,
+                    role = role,
+                    profileImage = image,
+                    banned = banned
+                )
+                accountApi.updateAccount(account, tokenManager.getAccessToken()!!)
+                onSuccess()
+            } catch (e: ClientException) {
+                e.printStackTrace()
+                error = "Invalid data"
+            } catch (e: ServerException) {
+                e.printStackTrace()
+                error = "Server error, please try again later"
+            } catch (e: IOException) {
+                e.printStackTrace()
+                error = "Network error, please check your connection"
+            } catch (e: Exception) {
+                e.printStackTrace()
+                error = "An unexpected error occurred"
+            }
+        }.invokeOnCompletion {
+            isLoading.value = false
+        }
+    }
+
+    fun deleteAccount(id: Long, onSuccess: () -> Unit) {
+        isLoading.value = true
+        viewModelScope.launch {
+            accountApi.deleteAccount(id, tokenManager.getAccessToken()!!)
+        }.invokeOnCompletion {
+            isLoading.value = false
+            onSuccess()
+        }
+    }
+
+    fun makeAdmin(id: Long, onSuccess: () -> Unit) {
+        isLoading.value = true
+        viewModelScope.launch {
+            accountApi.makeAdmin(id, tokenManager.getAccessToken()!!)
+        }.invokeOnCompletion {
+            isLoading.value = false
+            onSuccess()
+        }
+    }
+
+    fun revokeAdmin(id: Long, onSuccess: () -> Unit) {
+        isLoading.value = true
+        viewModelScope.launch {
+            accountApi.removeAdmin(id, tokenManager.getAccessToken()!!)
+        }.invokeOnCompletion {
+            isLoading.value = false
+            onSuccess()
+        }
+    }
+
+    fun banAccount(id: Long, onSuccess: () -> Unit) {
+        isLoading.value = true
+        viewModelScope.launch {
+            accountApi.banAccount(id, tokenManager.getAccessToken()!!)
+        }.invokeOnCompletion {
+            isLoading.value = false
+            onSuccess()
+        }
+    }
+
+    fun unbanAccount(id: Long, onSuccess: () -> Unit) {
+        isLoading.value = true
+        viewModelScope.launch {
+            accountApi.unbanAccount(id, tokenManager.getAccessToken()!!)
+        }.invokeOnCompletion {
+            isLoading.value = false
+            onSuccess()
+        }
+    }
+
+    fun getById(id: Long) {
+        isLoading.value = true
+        viewModelScope.launch {
+            val account = accountApi.getAccountById(id)
+            _account.value = account
+        }.invokeOnCompletion {
+            isLoading.value = false
+        }
+    }
+
+    fun updatePassword(oldPassword: String, newPassword: String, confirmPassword: String, onSuccess: () -> Unit) {
+        isLoading.value = true
+        viewModelScope.launch {
+            try {
+                accountApi.changePassword(
+                    ChangePasswordRequest(
+                        currentPassword = oldPassword,
+                        newPassword = newPassword,
+                        confirmationPassword = confirmPassword
+                    ),
+                    tokenManager.getAccessToken()!!
+                )
+                onSuccess()
+            } catch(e: JsonEncodingException) {
+                Log.w("Moshi", "Fuck Moshi :)")
+                onSuccess()
+            } catch (e: ClientException) {
+                e.printStackTrace()
+                error = "Invalid data"
+            } catch (e: ServerException) {
+                e.printStackTrace()
+                error = "Server error, please try again later"
+            } catch (e: IOException) {
+                e.printStackTrace()
+                error = "Network error, please check your connection"
+            } catch (e: Exception) {
+                e.printStackTrace()
+                error = "An unexpected error occurred"
+            }
+        }.invokeOnCompletion {
+            isLoading.value = false
+        }
+    }
+
+    fun updateImage(image: Bitmap, id: Long, email: String, firstName: String, onSuccess: () -> Unit) {
+        isLoading.value = true
+        viewModelScope.launch {
+            try {
+                accountApi.updateImage(
+                    AccountShortDto(
+                        id = id,
+                        email = email,
+                        firstname = firstName,
+                        profileImage = image
+                ), tokenManager.getAccessToken()!!)
+                onSuccess()
+            } catch(e: JsonEncodingException) {
+                Log.w("Moshi", "Fuck Moshi :)")
+                onSuccess()
+            } catch (e: ClientException) {
+                e.printStackTrace()
+                error = "Invalid data"
+            } catch (e: ServerException) {
+                e.printStackTrace()
+                error = "Server error, please try again later"
+            } catch (e: IOException) {
+                e.printStackTrace()
+                error = "Network error, please check your connection"
+            } catch (e: Exception) {
+                e.printStackTrace()
+                error = "An unexpected error occurred"
+            }
+        }.invokeOnCompletion {
+            isLoading.value = false
+        }
+    }
+
+    fun getAllAccounts() {
+        isLoading.value = true
+        viewModelScope.launch {
+            val list = accountApi.getAllAccounts(tokenManager.getAccessToken()!!)
+            _adminState.value = _adminState.value.copy(
+                accounts = list
+            )
+        }.invokeOnCompletion {
+            isLoading.value = false
+        }
+    }
 }
\ No newline at end of file
diff --git a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/viewmodel/LoginViewModel.kt b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/viewmodel/LoginViewModel.kt
index e235073..25e7336 100644
--- a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/viewmodel/LoginViewModel.kt
+++ b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/viewmodel/LoginViewModel.kt
@@ -1,21 +1,31 @@
 package it.unical.informatica.ea.sefora_frontend.viewmodel
 
+import android.annotation.SuppressLint
+import android.util.Log
 import androidx.compose.runtime.getValue
 import androidx.compose.runtime.mutableStateOf
 import androidx.compose.runtime.setValue
 import androidx.lifecycle.ViewModel
 import androidx.lifecycle.viewModelScope
-import it.unical.informatica.ea.sefora_frontend.activity.performRegistration
-import it.unical.informatica.ea.sefora_frontend.apis.UserControllerApi
+import dagger.hilt.android.lifecycle.HiltViewModel
+import it.unical.informatica.ea.sefora_frontend.apis.AccountControllerApi
+import it.unical.informatica.ea.sefora_frontend.auth.TokenManager
 import it.unical.informatica.ea.sefora_frontend.infrastructure.ClientException
 import it.unical.informatica.ea.sefora_frontend.infrastructure.ServerException
+import it.unical.informatica.ea.sefora_frontend.models.AccountDto
 import it.unical.informatica.ea.sefora_frontend.models.AuthenticationRequest
 import it.unical.informatica.ea.sefora_frontend.models.RegisterRequest
+import kotlinx.coroutines.flow.MutableStateFlow
+import kotlinx.coroutines.flow.StateFlow
 import kotlinx.coroutines.launch
 import java.io.IOException
-import java.util.regex.Pattern
+import javax.inject.Inject
 
-class LoginViewModel : ViewModel() {
+@SuppressLint("StaticFieldLeak")
+@HiltViewModel
+class LoginViewModel @Inject constructor(
+    val tokenManager: TokenManager,
+) : ViewModel() {
 
     var email by mutableStateOf("")
         private set
@@ -41,28 +51,49 @@ class LoginViewModel : ViewModel() {
         private set
     var error by mutableStateOf<String?>(null)
 
-    val _userControllerApi = UserControllerApi()
+    private val _accountControllerApi = AccountControllerApi()
+    private val _isLoggedIn = MutableStateFlow(false)
+    val alreadyLoggedIn: StateFlow<Boolean> = _isLoggedIn
+    val account = MutableStateFlow<AccountDto?>(null)
+
+    init {
+        viewModelScope.launch {
+            try {
+                if (tokenManager.getAccessToken() != null) {
+                    Log.w("LoginViewModel", "Token is not null, getting current user")
+                    getCurrentUser()
+                }
+            } catch (e: Exception) {
+                e.printStackTrace()
+            } finally {
+                _isLoggedIn.value = tokenManager.isAccessTokenExpired().not()
+                if (!_isLoggedIn.value) {
+                    tokenManager.clearTokens()
+                }
+            }
+        }
+    }
 
     fun onEmailChanged(newEmail: String) {
         email = newEmail
-        emailError = if (!isValidEmail(newEmail)) "Invalid email format" else null
+        emailError = if (!AccountDto.validateEmail(newEmail)) "Invalid email format" else null
     }
 
     fun onPasswordChanged(newPassword: String) {
         password = newPassword
-        passwordError = if (!isValidPassword(newPassword)) "Password must match requirements" else null
+        passwordError = if (!AccountDto.validatePassword(newPassword)) "Password must match requirements" else null
         // Controlla anche la corrispondenza con la conferma password
         confirmPasswordError = if (newPassword != confirmPassword) "Passwords do not match" else null
     }
 
     fun onFirstNameChanged(newFirstName: String) {
         firstName = newFirstName
-        firstNameError = if (!isValidFirstName(newFirstName)) "Invalid name" else null
+        firstNameError = if (!AccountDto.validateFirstName(newFirstName)) "Invalid name" else null
     }
 
     fun onLastNameChanged(newLastName: String) {
         lastName = newLastName
-        lastNameError = if (!isValidLastName(newLastName)) "Invalid surname" else null
+        lastNameError = if (!AccountDto.validateLastName(newLastName)) "Invalid last name" else null
     }
 
     fun onConfirmPasswordChanged(newConfirmPassword: String) {
@@ -83,18 +114,24 @@ class LoginViewModel : ViewModel() {
 
     // Authentication/Registration Logic
     fun login(onSuccess: () -> Unit) {
-        // Clear any previous error
         error = null
-
         viewModelScope.launch {
             try {
                 if (emailError == null && passwordError == null) {
-                    _userControllerApi.authenticate(
+                    val response = _accountControllerApi.authenticate(
                         AuthenticationRequest(
                             email = email,
                             password = password
                         )
                     )
+                    tokenManager.saveTokens(
+                        accessToken = response.accessToken,
+                        refreshToken = response.refreshToken,
+                        account = response.account,
+                        expires_in = response.expiresIn
+                    )
+                    account.value = response.account
+                    _isLoggedIn.value = true
                     onSuccess()
                 } else {
                     error = "Invalid email or password format"
@@ -118,12 +155,11 @@ class LoginViewModel : ViewModel() {
         }
     }
 
-
     fun register(onSuccess: () -> Unit) {
         viewModelScope.launch {
             try {
                 if (emailError == null && passwordError == null && firstNameError == null && lastNameError == null) {
-                    _userControllerApi.register(
+                    val response = _accountControllerApi.register(
                         RegisterRequest(
                             email = email,
                             password = password,
@@ -132,6 +168,14 @@ class LoginViewModel : ViewModel() {
                             role = RegisterRequest.Role.USER
                         )
                     )
+                    tokenManager.saveTokens(
+                        accessToken = response.accessToken,
+                        refreshToken = response.refreshToken,
+                        account = response.account,
+                        expires_in = response.expiresIn
+                    )
+                    account.value = response.account
+                    _isLoggedIn.value = true
                     onSuccess()
                 }
             } catch (e: ClientException) {
@@ -148,6 +192,7 @@ class LoginViewModel : ViewModel() {
                 error = "An unexpected error occurred"
             } finally {
                 password = ""
+                confirmPassword = ""
                 email = ""
                 firstName = ""
                 lastName = ""
@@ -155,38 +200,32 @@ class LoginViewModel : ViewModel() {
         }
     }
 
-    // Helper function for email validation
-    private fun isValidEmail(email: String): Boolean {
-        val emailRegex = Pattern.compile(
-            "[a-zA-Z0-9\\+\\.\\_\\%\\-\\+]{1,256}" +
-                    "\\@" +
-                    "[a-zA-Z0-9][a-zA-Z0-9\\-]{0,64}" +
-                    "(" +
-                    "\\." +
-                    "[a-zA-Z0-9][a-zA-Z0-9\\-]{0,25}" +
-                    ")+"
-        )
-        return emailRegex.matcher(email).matches()
-    }
-
-    private fun isValidPassword(password: String): Boolean {
-        // Definisci i requisiti di validità della password
-        val passwordRegex = Pattern.compile(
-            "^(?=.*[0-9])(?=.*[a-z])(?=.*[A-Z])(?=.*[!@#\$%^&*()_+\\-=\\[\\]{};':\"\\\\|,.<>\\/?]).{8,}$"
-        )
-        return passwordRegex.matcher(password).matches()
-    }
-
-    private fun isValidFirstName(firstName: String): Boolean {
-        // Definisci i requisiti di validità del nome
-        val firstNameRegex = Pattern.compile("^[a-zA-Z\\s]+$") // Solo lettere e spazi
-        return firstNameRegex.matcher(firstName).matches() && firstName.isNotEmpty() // Non vuoto
+    fun getCurrentUser() {
+        viewModelScope.launch {
+            try {
+                val response = _accountControllerApi.getConnectedAccount(tokenManager.getAccessToken()!!)
+                tokenManager.saveTokens(
+                    accessToken = tokenManager.getAccessToken()!!,
+                    refreshToken = tokenManager.getRefreshToken()!!,
+                    account = response,
+                    expires_in = tokenManager.getTimeUntilTokenExpires()
+                )
+                account.value = response
+            } catch (e: Exception) {
+                e.printStackTrace()
+                Log.w("LoginViewModel", "Something happened, forcing user to log in anyway.")
+                tokenManager.clearTokens()
+            } finally {
+                _isLoggedIn.value = tokenManager.isAccessTokenExpired().not()
+            }
+        }
     }
 
-    private fun isValidLastName(lastName: String): Boolean {
-        // Definisci i requisiti di validità del cognome
-        val lastNameRegex = Pattern.compile("^[a-zA-Z\\s]+$") // Solo lettere e spazi
-        return lastNameRegex.matcher(lastName).matches() && lastName.isNotEmpty() // Non vuoto
+    fun logout() {
+        viewModelScope.launch {
+            _accountControllerApi.logout(tokenManager.getAccessToken()!!)
+            tokenManager.clearTokens()
+            _isLoggedIn.value = false
+        }
     }
-
-}
+}
\ No newline at end of file
diff --git a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/viewmodel/ProductViewModel.kt b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/viewmodel/ProductViewModel.kt
index b45fc44..b7a4e89 100644
--- a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/viewmodel/ProductViewModel.kt
+++ b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/viewmodel/ProductViewModel.kt
@@ -1,4 +1,33 @@
 package it.unical.informatica.ea.sefora_frontend.viewmodel
 
-class ProductViewModel {
+import android.graphics.Bitmap
+import androidx.lifecycle.ViewModel
+import dagger.hilt.android.lifecycle.HiltViewModel
+import it.unical.informatica.ea.sefora_frontend.apis.ProductControllerApi
+import it.unical.informatica.ea.sefora_frontend.auth.TokenManager
+import kotlinx.coroutines.flow.MutableStateFlow
+import kotlinx.coroutines.flow.StateFlow
+import kotlinx.coroutines.flow.asStateFlow
+import it.unical.informatica.ea.sefora_frontend.models.ProductDto
+import javax.inject.Inject
+
+data class ProductState(
+    val name: String="",
+    val price: Double=0.0,
+    val description: String="",
+    val image: List<Bitmap> = listOf(),
+    val category: ProductDto.Category?= null,
+    val quantity: Int=0,
+)
+
+@HiltViewModel
+class ProductViewModel @Inject constructor(
+    val tokenManager: TokenManager,
+) : ViewModel() {
+
+    private val productApi: ProductControllerApi = ProductControllerApi()
+    private val _productState = MutableStateFlow(ProductState())
+    val productState: StateFlow<ProductState> = _productState.asStateFlow()
+    private val _product = MutableStateFlow<ProductDto?>(null)
+    val product: StateFlow<ProductDto?> = _product.asStateFlow()
 }
\ No newline at end of file
diff --git a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/viewmodel/PurchaseViewModel.kt b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/viewmodel/PurchaseViewModel.kt
index 2c47c31..fe60a78 100644
--- a/app/src/main/java/it/unical/informatica/ea/sefora_frontend/viewmodel/PurchaseViewModel.kt
+++ b/app/src/main/java/it/unical/informatica/ea/sefora_frontend/viewmodel/PurchaseViewModel.kt
@@ -1,39 +1,58 @@
 package it.unical.informatica.ea.sefora_frontend.viewmodel
 
-import android.content.Context
-import androidx.compose.runtime.MutableState
 import androidx.compose.runtime.mutableStateOf
 import androidx.lifecycle.ViewModel
 import androidx.lifecycle.viewModelScope
-import it.unical.informatica.ea.sefora_frontend.apis.OrderControllerApi
-import it.unical.informatica.ea.sefora_frontend.apis.OrderProductControllerApi
+import dagger.hilt.android.lifecycle.HiltViewModel
+import it.unical.informatica.ea.sefora_frontend.apis.PurchaseControllerApi
 import it.unical.informatica.ea.sefora_frontend.auth.TokenManager
-import it.unical.informatica.ea.sefora_frontend.models.OrderDto
-import it.unical.informatica.ea.sefora_frontend.models.OrderProductDto
-import it.unical.informatica.ea.sefora_frontend.models.UserDto
+import it.unical.informatica.ea.sefora_frontend.models.PurchaseDto
+import kotlinx.coroutines.flow.MutableStateFlow
+import kotlinx.coroutines.flow.StateFlow
+import kotlinx.coroutines.flow.asStateFlow
 import kotlinx.coroutines.launch
+import javax.inject.Inject
 
-class OrderViewModel(val context : Context) :ViewModel() {
+data class PurchaseState(
+    val purchases: List<PurchaseDto> = emptyList()
+)
 
-    private val orderApi: OrderControllerApi = OrderControllerApi()
-    private val orderProductControllerApi = OrderProductControllerApi()
-    private val tokenManager = TokenManager(context)
-    val orderList: MutableState<Array<Pair<OrderDto, List<OrderProductDto>>>> = mutableStateOf(emptyArray())
-    var currentUser: UserDto? = null
+@HiltViewModel
+class PurchaseViewModel @Inject constructor(
+    private val tokenManager: TokenManager
+) :ViewModel() {
+    private val purchaseApi: PurchaseControllerApi = PurchaseControllerApi()
+    val isLoading = mutableStateOf(false)
+
+    private val _purchases = MutableStateFlow(PurchaseState())
+    val purchases: StateFlow<PurchaseState> = _purchases.asStateFlow()
 
     init {
+        getPurchases()
+    }
+
+    fun getPurchases() {
+        isLoading.value = true
         viewModelScope.launch {
-            currentUser = tokenManager.getUser()
-            getOrders(currentUser!!.id!!)
+            try {
+                val purchases = purchaseApi.findOrdersByCurrentUser(tokenManager.getAccessToken()!!)
+                _purchases.value = _purchases.value.copy(
+                    purchases = purchases
+                )
+            } catch (e: Exception) {
+                e.printStackTrace()
+            }
+            isLoading.value = false
         }
     }
-
-    fun getOrders(id: Long) {
+    fun convertProductToPurchase(productId: Long, onSuccess: () -> Unit) {
         viewModelScope.launch {
-            val orders = orderApi.findOrdersbyUserId(id)
-            orderList.value = orders.map { order ->
-                order to orderProductControllerApi.getOrderProductsByOrderId(order.id!!)
-            }.toTypedArray()
+            try {
+                purchaseApi.convertProductToPurchase(productId, tokenManager.getAccessToken()!!)
+                onSuccess()
+            } catch (e: Exception) {
+                e.printStackTrace()
+            }
         }
     }
 }
\ No newline at end of file
diff --git a/app/src/main/res/mipmap-anydpi/ic_launcher.xml b/app/src/main/res/mipmap-anydpi/ic_launcher.xml
deleted file mode 100644
index 6f3b755..0000000
--- a/app/src/main/res/mipmap-anydpi/ic_launcher.xml
+++ /dev/null
@@ -1,6 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
-    <background android:drawable="@drawable/ic_launcher_background" />
-    <foreground android:drawable="@drawable/ic_launcher_foreground" />
-    <monochrome android:drawable="@drawable/ic_launcher_foreground" />
-</adaptive-icon>
\ No newline at end of file
diff --git a/app/src/main/res/mipmap-anydpi/ic_launcher_round.xml b/app/src/main/res/mipmap-anydpi/ic_launcher_round.xml
deleted file mode 100644
index 6f3b755..0000000
--- a/app/src/main/res/mipmap-anydpi/ic_launcher_round.xml
+++ /dev/null
@@ -1,6 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
-    <background android:drawable="@drawable/ic_launcher_background" />
-    <foreground android:drawable="@drawable/ic_launcher_foreground" />
-    <monochrome android:drawable="@drawable/ic_launcher_foreground" />
-</adaptive-icon>
\ No newline at end of file
diff --git a/app/src/main/res/mipmap-hdpi/ic_launcher.webp b/app/src/main/res/mipmap-hdpi/ic_launcher.webp
index c209e78..de9de3d 100644
Binary files a/app/src/main/res/mipmap-hdpi/ic_launcher.webp and b/app/src/main/res/mipmap-hdpi/ic_launcher.webp differ
diff --git a/app/src/main/res/mipmap-hdpi/ic_launcher_round.webp b/app/src/main/res/mipmap-hdpi/ic_launcher_round.webp
index b2dfe3d..de9de3d 100644
Binary files a/app/src/main/res/mipmap-hdpi/ic_launcher_round.webp and b/app/src/main/res/mipmap-hdpi/ic_launcher_round.webp differ
diff --git a/app/src/main/res/mipmap-mdpi/ic_launcher.webp b/app/src/main/res/mipmap-mdpi/ic_launcher.webp
index 4f0f1d6..4e42483 100644
Binary files a/app/src/main/res/mipmap-mdpi/ic_launcher.webp and b/app/src/main/res/mipmap-mdpi/ic_launcher.webp differ
diff --git a/app/src/main/res/mipmap-mdpi/ic_launcher_round.webp b/app/src/main/res/mipmap-mdpi/ic_launcher_round.webp
index 62b611d..4e42483 100644
Binary files a/app/src/main/res/mipmap-mdpi/ic_launcher_round.webp and b/app/src/main/res/mipmap-mdpi/ic_launcher_round.webp differ
diff --git a/app/src/main/res/mipmap-xhdpi/ic_launcher.webp b/app/src/main/res/mipmap-xhdpi/ic_launcher.webp
index 948a307..808794d 100644
Binary files a/app/src/main/res/mipmap-xhdpi/ic_launcher.webp and b/app/src/main/res/mipmap-xhdpi/ic_launcher.webp differ
diff --git a/app/src/main/res/mipmap-xhdpi/ic_launcher_round.webp b/app/src/main/res/mipmap-xhdpi/ic_launcher_round.webp
index 1b9a695..808794d 100644
Binary files a/app/src/main/res/mipmap-xhdpi/ic_launcher_round.webp and b/app/src/main/res/mipmap-xhdpi/ic_launcher_round.webp differ
diff --git a/app/src/main/res/mipmap-xxhdpi/ic_launcher.webp b/app/src/main/res/mipmap-xxhdpi/ic_launcher.webp
index 28d4b77..df5b2b6 100644
Binary files a/app/src/main/res/mipmap-xxhdpi/ic_launcher.webp and b/app/src/main/res/mipmap-xxhdpi/ic_launcher.webp differ
diff --git a/app/src/main/res/mipmap-xxhdpi/ic_launcher_round.webp b/app/src/main/res/mipmap-xxhdpi/ic_launcher_round.webp
index 9287f50..df5b2b6 100644
Binary files a/app/src/main/res/mipmap-xxhdpi/ic_launcher_round.webp and b/app/src/main/res/mipmap-xxhdpi/ic_launcher_round.webp differ
diff --git a/app/src/main/res/mipmap-xxxhdpi/ic_launcher.webp b/app/src/main/res/mipmap-xxxhdpi/ic_launcher.webp
index aa7d642..1629dc0 100644
Binary files a/app/src/main/res/mipmap-xxxhdpi/ic_launcher.webp and b/app/src/main/res/mipmap-xxxhdpi/ic_launcher.webp differ
diff --git a/app/src/main/res/mipmap-xxxhdpi/ic_launcher_round.webp b/app/src/main/res/mipmap-xxxhdpi/ic_launcher_round.webp
index 9126ae3..1629dc0 100644
Binary files a/app/src/main/res/mipmap-xxxhdpi/ic_launcher_round.webp and b/app/src/main/res/mipmap-xxxhdpi/ic_launcher_round.webp differ
diff --git a/build.gradle.kts b/build.gradle.kts
index 1e81c0e..7770723 100644
--- a/build.gradle.kts
+++ b/build.gradle.kts
@@ -2,6 +2,13 @@
 plugins {
     alias(libs.plugins.android.application) apply false
     alias(libs.plugins.jetbrains.kotlin.android) apply false
+
+}
+
+buildscript {
+    dependencies {
+        classpath(libs.hilt.android.gradle.plugin)
+    }
 }
 
 
diff --git a/gradle/libs.versions.toml b/gradle/libs.versions.toml
index 959d3f1..ab2342c 100644
--- a/gradle/libs.versions.toml
+++ b/gradle/libs.versions.toml
@@ -1,10 +1,14 @@
 [versions]
-agp = "8.4.2"
+agp = "8.6.0"
+hiltAndroidGradlePlugin = "2.49"
+hiltCompiler = "1.2.0"
+hiltLifecycleViewmodel = "1.0.0-alpha03"
 kotlin = "1.9.0"
 coreKtx = "1.13.1"
 junit = "4.13.2"
 junitVersion = "1.2.1"
 espressoCore = "3.6.1"
+kotlinxSerializationJson = "1.6.0"
 lifecycleRuntimeKtx = "2.8.4"
 activityCompose = "1.9.1"
 composeBom = "2024.08.00"
@@ -13,9 +17,24 @@ moshi = "1.15.0"
 moshiKotlin = "1.15.0"
 okhttp = "4.11.0"
 json = "20210307"
+datastore = "1.1.1"
+playServicesAuth = "21.2.0"
+securityCrypto = "1.0.0"
+datastorePreferencesCoreJvm = "1.1.1"
+jwtdecode = "2.0.0"
+appauth = "0.10.0"
+ui = "1.6.8"
+uiGraphics = "1.6.8"
+uiGraphicsVersion = "1.6.8"
 
 [libraries]
+androidx-compose-ui-ui-graphics = { module = "androidx.compose.ui:ui-graphics", version.ref = "uiGraphicsVersion" }
 androidx-core-ktx = { group = "androidx.core", name = "core-ktx", version.ref = "coreKtx" }
+androidx-hilt-compiler = { module = "androidx.hilt:hilt-compiler", version.ref = "hiltCompiler" }
+androidx-hilt-navigation-compose = { module = "androidx.hilt:hilt-navigation-compose", version.ref = "hiltCompiler" }
+hilt-android = { module = "com.google.dagger:hilt-android", version.ref = "hiltAndroidGradlePlugin" }
+hilt-android-compiler = { module = "com.google.dagger:hilt-android-compiler", version.ref = "hiltAndroidGradlePlugin" }
+hilt-android-gradle-plugin = { module = "com.google.dagger:hilt-android-gradle-plugin", version.ref = "hiltAndroidGradlePlugin" }
 junit = { group = "junit", name = "junit", version.ref = "junit" }
 androidx-junit = { group = "androidx.test.ext", name = "junit", version.ref = "junitVersion" }
 androidx-espresso-core = { group = "androidx.test.espresso", name = "espresso-core", version.ref = "espressoCore" }
@@ -29,15 +48,24 @@ androidx-ui-tooling-preview = { group = "androidx.compose.ui", name = "ui-toolin
 androidx-ui-test-manifest = { group = "androidx.compose.ui", name = "ui-test-manifest" }
 androidx-ui-test-junit4 = { group = "androidx.compose.ui", name = "ui-test-junit4" }
 androidx-material3 = { group = "androidx.compose.material3", name = "material3" }
+kotlinx-serialization-json = { module = "org.jetbrains.kotlinx:kotlinx-serialization-json", version.ref = "kotlinxSerializationJson" }
 material-icons-extended = { group = "androidx.compose.material", name = "material-icons-extended" }
 material3 = { module = "androidx.compose.material3:material3", version.ref = "material3" }
 moshi = { module = "com.squareup.moshi:moshi", version.ref = "moshi" }
 moshi-kotlin = { module = "com.squareup.moshi:moshi-kotlin", version.ref = "moshiKotlin" }
 okhttp = { module = "com.squareup.okhttp3:okhttp", version.ref = "okhttp" }
 json = { module = "org.json:json", version.ref = "json" }
+play-services-auth = { module = "com.google.android.gms:play-services-auth", version.ref = "playServicesAuth" }
+ui = { module = "androidx.compose.ui:ui", version.ref = "ui" }
+ui-graphics = { module = "androidx.compose.ui.graphics:ui-graphics", version.ref = "uiGraphics" }
 window-size = { module = "androidx.compose.material3:material3-window-size-class", version.ref = "material3" }
+datastore = { module = "androidx.datastore:datastore", version.ref = "datastore" }
+security-crypto = { module = "androidx.security:security-crypto", version.ref = "securityCrypto" }
+androidx-datastore-preferences-core-jvm = { group = "androidx.datastore", name = "datastore-preferences-core-jvm", version.ref = "datastorePreferencesCoreJvm" }
+androidx-datastore-preferences = { group = "androidx.datastore", name = "datastore-preferences", version.ref = "datastorePreferencesCoreJvm" }
+jwtdecode = { module = "com.auth0.android:jwtdecode", version.ref = "jwtdecode" }
+appauth = { module = "net.openid:appauth", version.ref = "appauth" }
 
 [plugins]
 android-application = { id = "com.android.application", version.ref = "agp" }
-jetbrains-kotlin-android = { id = "org.jetbrains.kotlin.android", version.ref = "kotlin" }
-
+jetbrains-kotlin-android = { id = "org.jetbrains.kotlin.android", version.ref = "kotlin" }
\ No newline at end of file
